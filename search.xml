<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>你知道或不知道的单元测试</title>
      <link href="/2018/08/30/%E4%BD%A0%E7%9F%A5%E9%81%93%E6%88%96%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <content type="html"><![CDATA[<h3 id="为什么现在才开始"><a href="#为什么现在才开始" class="headerlink" title="为什么现在才开始"></a>为什么现在才开始</h3><p>其实之前有看过关于Junit的测试，也实际操作并践行着，但是总觉得自己还有所欠缺着些东西；</p><p>于是想想，我应该把自己平时对于测试方面，Junit的学习认识，记录下来，然后定期的修改，增补，让自己的知识进行沉积；</p><h3 id="为什么要单元测试"><a href="#为什么要单元测试" class="headerlink" title="为什么要单元测试"></a>为什么要单元测试</h3><p>单元测试的过程，并不是最终面向客户的甚至不是面向项目经理，开发组长，而是面向程序员自己的；</p><p>单元测试一开始就不是冲着为了获得一些更好的整体质量而设计的；</p><p>那为什么程序员还需要单元测试？</p><p>一个没有用处的东西，他存在的理由究竟是什么？</p><p>首先，我们得明白<strong>什么是单元测试？</strong></p><blockquote><p>单元测试是开发者编写的一小段代码，用于检测代码的一个很小的、很明确的功能是否正确。</p><p>执行单元测试是为了证明某段代码的行为确实和开发者期望的一致。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 单元 </tag>
            
            <tag> Junit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些版本命名小常识</title>
      <link href="/2018/08/24/%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E5%B0%8F%E5%B8%B8%E8%AF%86/"/>
      <content type="html"><![CDATA[<h5 id="1-Alpha版-内部测试版"><a href="#1-Alpha版-内部测试版" class="headerlink" title="1.Alpha版(内部测试版)"></a>1.Alpha版(内部测试版)</h5><p>  一般只在软件开发公司内部运行，不对外公开。主要是开发者自己对产品进行测试，检查产品是否存在缺陷、错误，验证产品功能与说明书、用户手册是否一致。Alpha版本的产品仍然需要完整的功能测试，而其功能亦未完善，但是可以满足一般需求。因为它是整个软件释出周期中的第一个主要阶段，所以它的名称是“Alpha”，希腊字母中的第一个字母。</p><p>  Alpha版本通常会送交到开发软件的组织或社群中的各个软件测试者，用作内部测试。在市场上，越来越多公司会邀请外部的客户或合作伙伴参与其软件的Alpha测试阶段。这令软件在此阶段有更大的可用性测试。</p><p>  在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。</p><h5 id="2-Beta版-外部测试版"><a href="#2-Beta版-外部测试版" class="headerlink" title="2.Beta版(外部测试版)"></a>2.Beta版(外部测试版)</h5><p>   软件开发公司为对外宣传，将非正式产品免费发送给具有典型性的用户，让用户测试该软件的不足之处及存在问题，以便在正式发行前进一步改进和完善。一般可通过Internet免费下载，也可以向软件公司索取。</p><p>  Beta版本是第一个对外公开的软件版本，是由公众参与的测试阶段。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的臭虫(Bug)。</p><p>  Beta版本的测试者通常是开发软件的组织的客户，他们会以免费或优惠价钱得到软件，但会成为组织的免费测试者。</p><p>  Beta版本主要测试产品的支援和市场反应（在邀请Beta用户时）等。</p><h5 id="3-Demo版-演示版"><a href="#3-Demo版-演示版" class="headerlink" title="3.Demo版(演示版)"></a>3.Demo版(演示版)</h5><p>   主要是演示正式软件的部分功能，用户可以从中得知软件的基本操作，为正式产品的发售扩大影响。如果是游戏的话，则只有一两个关卡可以玩。该版本也可以从Internet上免费下载。</p><h5 id="4-Enhanced版-增强版或加强版"><a href="#4-Enhanced版-增强版或加强版" class="headerlink" title="4.Enhanced版(增强版或加强版)"></a>4.Enhanced版(增强版或加强版)</h5><p>   如果是一般软件，一般称作“增强版”，会加入一些实用的新功能。如果是游戏，一般称作“加强版”，会加入一些新的游戏场景和游戏情节等。这是正式发售的版本。</p><h5 id="5-Free版-自由版"><a href="#5-Free版-自由版" class="headerlink" title="5.Free版(自由版)"></a>5.Free版(自由版)</h5><p>   这一般是个人或自由软件联盟组织的成员制作的软件，希望免费给大家使用，没有版权，一般也是通过Internet免费下载。</p><h5 id="6-Full-Version版-完全版"><a href="#6-Full-Version版-完全版" class="headerlink" title="6.Full Version版(完全版)"></a>6.Full Version版(完全版)</h5><p>  也就是正式版，是最终正式发售的版本。</p><h5 id="7-Shareware版-共享版"><a href="#7-Shareware版-共享版" class="headerlink" title="7.Shareware版(共享版)"></a>7.Shareware版(共享版)</h5><p>  有些公司为了吸引客户，对于他们制作的某些软件，可以让用户通过Internet免费下载的方式获取。不过，此版本软件多会带有一些使用时间或次数的限制，但可以利用在线注册或电子注册成为正式版用户。</p><h5 id="8-Release版-发行版"><a href="#8-Release版-发行版" class="headerlink" title="8.Release版(发行版)"></a>8.Release版(发行版)</h5><p>  不是正式版，带有时间限制，也是为扩大影响所做的宣传策略之一。比如Windows Me的发行版就限制了只能使用几个月，可从Internet上免费下载或由公司免费奉送。</p><p>  Release Candidate（简称RC）指可能成为最终产品的版本，如果没有再出现问题则可释出正式版本。在此阶段，产品包含所有功能亦不会出现严重问题。通常此阶段的产品是接近完整的。</p><p>  微软公司很多时会使用此名称。在1990年代，苹果电脑把在这阶段的产品称为“Golden Master”，而最后的Golden Master为正式版本。这阶段亦称Gamma（更后期的称为Delta，及其后的希腊字母）。</p><h5 id="9-Uprgade版-升级版"><a href="#9-Uprgade版-升级版" class="headerlink" title="9.Uprgade版(升级版)"></a>9.Uprgade版(升级版)</h5><p>  当你有某个软件以前的正式版本时，可以购买升级版，将你的软件升级为最新版。升级后的软件与正式版在功能上相同，但价格会低些，这主要是为了给原有的正版用户提供优惠。</p><h5 id="10-Retail版-（零售版）"><a href="#10-Retail版-（零售版）" class="headerlink" title="10.Retail版 （零售版）"></a>10.Retail版 （零售版）</h5><p>  一般只针对个人的功能不是很全的版本，价格比较低，升级时间也有限制。</p><h5 id="11-Cardware版"><a href="#11-Cardware版" class="headerlink" title="11.Cardware版"></a>11.Cardware版</h5><p>  属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。</p><h5 id="12-Plus版（增强版）"><a href="#12-Plus版（增强版）" class="headerlink" title="12.Plus版（增强版）"></a>12.Plus版（增强版）</h5><p>  不过这种大部分是在程序界面及多媒体功能上增强。</p><h5 id="13-Preview版（预览版）"><a href="#13-Preview版（预览版）" class="headerlink" title="13.Preview版（预览版）"></a>13.Preview版（预览版）</h5><p>  软件商为了满足那些对新版本很关注的人，发布的可以看到大部分功能的测试软件。</p><h5 id="14-Corporation-amp-Enterprise版（企业版）"><a href="#14-Corporation-amp-Enterprise版（企业版）" class="headerlink" title="14.Corporation &amp; Enterprise版（企业版）"></a>14.Corporation &amp; Enterprise版（企业版）</h5><p>  只针对企业发布的全功能版本，价格比较昂贵，服务非常齐全。</p><h5 id="15-Standard版（标准版）"><a href="#15-Standard版（标准版）" class="headerlink" title="15.Standard版（标准版）"></a>15.Standard版（标准版）</h5><p>  软件商推荐大家使用的版本，这种版本一般比较稳定，BUG少。</p><h5 id="16-Mini版"><a href="#16-Mini版" class="headerlink" title="16.Mini版"></a>16.Mini版</h5><p>  迷你版也叫精简版只有最基本的功能，为那些想节省硬盘空间或者不追求华丽的人准备的。</p><h5 id="17-Rip"><a href="#17-Rip" class="headerlink" title="17.Rip"></a>17.Rip</h5><p>  是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！</p><p>  另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。</p><h5 id="18-trial-试用版"><a href="#18-trial-试用版" class="headerlink" title="18. trial 试用版"></a>18. trial 试用版</h5><p>  （含有某些限制，如时间、功能，注册后也有可能变为正式版）</p><h5 id="19-RTM-版"><a href="#19-RTM-版" class="headerlink" title="19.RTM 版"></a>19.RTM 版</h5><p>  这基本就是最终的版本，英文是 Release To Manufactur，意思是发布到生产商。</p><h5 id="20-Unregistered"><a href="#20-Unregistered" class="headerlink" title="20.Unregistered"></a>20.Unregistered</h5><p>  未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。</p><h5 id="21-Regged"><a href="#21-Regged" class="headerlink" title="21.Regged"></a>21.Regged</h5><p>已注册版</p><h5 id="22-Lite"><a href="#22-Lite" class="headerlink" title="22.Lite"></a>22.Lite</h5><p>精简版。</p><h5 id="23-Full-version"><a href="#23-Full-version" class="headerlink" title="23.Full version"></a>23.Full version</h5><p>完整版，属于正式版</p><h5 id="24-SC"><a href="#24-SC" class="headerlink" title="24.SC"></a>24.SC</h5><p>Simplified Chinese简体中文版。</p><h5 id="25-CN"><a href="#25-CN" class="headerlink" title="25.CN"></a>25.CN</h5><p>简体中文版</p><h5 id="26-GBK"><a href="#26-GBK" class="headerlink" title="26.GBK"></a>26.GBK</h5><p>简体中文汉字内码扩展规范版。</p><h5 id="27-TC"><a href="#27-TC" class="headerlink" title="27.TC"></a>27.TC</h5><p> Traditional Chinese繁体中文版。</p><h5 id="28-CHT"><a href="#28-CHT" class="headerlink" title="28.CHT"></a>28.CHT</h5><p>繁体中文版</p><h5 id="29-BIG5"><a href="#29-BIG5" class="headerlink" title="29.BIG5"></a>29.BIG5</h5><p>繁体中文大五码版。</p><h5 id="30-EN"><a href="#30-EN" class="headerlink" title="30.EN"></a>30.EN</h5><p>英文版</p><h5 id="31-Multilanguage"><a href="#31-Multilanguage" class="headerlink" title="31.Multilanguage"></a>31.Multilanguage</h5><p>语言版</p><h5 id="32-UTF8"><a href="#32-UTF8" class="headerlink" title="32.UTF8"></a>32.UTF8</h5><p>Unicode Transformation Format 8 bit，对现有的中文系统不是好的解决方案。</p><h5 id="33-γ（Gamma）版"><a href="#33-γ（Gamma）版" class="headerlink" title="33.γ（Gamma）版"></a>33.γ（Gamma）版</h5><p>相当成熟的测试版，与即将发行的正式版相差无几。</p><h5 id="34-SR版"><a href="#34-SR版" class="headerlink" title="34.SR版"></a>34.SR版</h5><p>修正版或更新版，修正了正式版推出后发现的Bug。</p><p>Final版：正式版。</p><h5 id="35-OEM"><a href="#35-OEM" class="headerlink" title="35.OEM"></a>35.OEM</h5><p>Original Equipment Manufacturer 是给电脑生产厂的版本，无需多说。</p><h5 id="36-FPP"><a href="#36-FPP" class="headerlink" title="36.FPP"></a>36.FPP</h5><p>  Full Packaged Product (FPP)/Retail 就是零售版（盒装软件），这种产品的光盘的卷标都带有”FPP”字样，比如英文WXP Pro的FPP版本的光盘卷标就是WXPFPP_EN，其中WX表示是Windows XP，P是Professional（H是Home），FPP表明是零售版本，EN是表明是英语。获得途径除了在商店购买之外，某些MSDN用户也可以得到。</p><h5 id="37-VLO"><a href="#37-VLO" class="headerlink" title="37.VLO"></a>37.VLO</h5><p>  Volume Licensing for Organizations (VLO) 团体批量许可证（大量采购授权合约），这是为团体购买而制定的一种优惠方式。这种产品的光盘的卷标都带有”VOL”字样，取”Volume”前3个字母，以表明是批量，比如英文WXP Pro的VOL版本的光盘卷标就是WXPVOL_EN，其中WX表示是Windows XP，P是Professional（VOL没有Home版本），VOL表明是团体批量许可证版本，EN是表明是英语。获得途径主要是集团购买，某些MSDN用户也可以得到。</p><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>V（Version）：即版本，通常用数字表示版本号。(如:EVEREST Ultimate v4.20.1188 Beta )</p><p>Build：用数字或日期标示版本号的一种方式。(如:VeryCD eMule v0.48a Build 071112)</p><p>SP：Service Pack，升级包。(如:Windows XP SP 2/VistaSP 1/Windows7SP1)</p>]]></content>
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本 </tag>
            
            <tag> 小常识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于subversion的一些知识</title>
      <link href="/2018/05/31/%E5%85%B3%E4%BA%8Esubversion%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <content type="html"><![CDATA[<p>前面，有一篇文章专门提到了，<strong>重新认识版本管理</strong>，并提到的<strong>版本管理的重要性</strong>；</p><p>作为一名程序员，少不了对自己的要求越来越严格，但是如何严谨的规范和约束自己，包括自己所在的团队呢？</p><p>在之前，我的一位大佬，跟我们说了这么一段话：</p><blockquote><p>做事情呢，一定要讲究 <strong>道</strong>，<strong>法</strong>，<strong>术</strong>，<strong>器</strong>；</p></blockquote><p>前面的各有各的说法，我们着重讲解一下，这个<strong>器</strong>；</p><p>这里我将聚焦在更详细的地方，当然是有出处的——出自《版本管理之道-使用subversion》；</p><p>感兴趣的朋友不妨去下载看看，或者购买纸质的书籍，也不算厚，相信即使你是初学者，一个星期的时间也能读完本书并掌握基础的技能；</p><p>这里算是我的学习笔记，不完全抄自本书，会结合部分自己的见解加以深入思考；</p><h2 id="SVN的基础内容"><a href="#SVN的基础内容" class="headerlink" title="SVN的基础内容"></a>SVN的基础内容</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>版本从何而来呢？每一次的增、删、改都会在SVN（subversion的简写，后面均称为SVN）中标记一个新版本；</p><p>用过CVS（<em>Concurrent Versions System 并行版本系统的简称</em>），就会知道这里有点区别；</p><p><strong>CVS</strong>记录的是<strong>单个文件的版本</strong>,而<strong>SVN</strong>记录的是整个<strong>项目仓库的版本</strong>;</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>很多时候，我们都无法记住r677到底用于干什么的？但我们准能记住V3.0这种，第三正式版本；</p><p>版本控制系统让你可以给<strong>某一时刻的一组文件、或者一些目录或者整个项目分配一个名字</strong>。</p><p>如果你们的项目开发到达了一定程度，你标记为 <strong>v2.0 beta</strong>，你以后就能用这个标签签出他们；</p><blockquote><p>标签是一种很好的跟踪项目代码开发过程中发生重要事件的方式；</p></blockquote><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>当我们一个项目组对同一份源代码添加，修改内容，并进行签入和签出的时候，大家都共享这份源代码；</p><p>我们将这份居于主要地位的源代码称为<strong>主干</strong>；</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1527747888648.png" alt="主干"></p><p>那么<strong>分支</strong>又是一个怎样的需求呢？为什么会产生分支这种情况；</p><p>我们可以把主干和分支想象成你所在的时空和另外一个由你本身所做的出改变而产生的另外一个时空；</p><p>通俗一点说，当我们开发到一定过程的时候， 我们需要发布V2.0版本了，这个时候，上线是需要稳定，和减少bug的；</p><p>你不可能说拿着一堆在开发的东西就给客户，至少你需要粉饰一下，而你能怎么做呢？</p><ol><li>让大家都停下手中的活，向着发布的方向进行改动？</li><li>拷贝到其他地方，重新开始，那怎么比对项目最开始的地方，进行跟踪和修正呢？（别跟我说重开一个服务器什么的）</li></ol><p>这个时候，就产生了这样的需求“分支”；</p><blockquote><p>老实说，我还是觉得这样的解释，弱化了分支的功能，有点强行解释的味道，后面我加深理解，再做扩展；</p></blockquote><p>分支产生以后，主开发团队可以继续对着之前的主线干活；</p><p>而发布团队，则对分支进行修正，比对而又能对过去的问题进行持续的跟踪；</p><p>这里作者还说了一个问题，有人被分支搞到头大，是因为过度使用分支，而这样最后会发现，你在合并的时候，痛苦异常；</p><p>我想这位老兄肯定是穿越了太多的平行空间，就像<strong>盗梦空间</strong>里那样，梦太多回不去了…</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1527750672884.png" alt="主干与分支"></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>在这里想到了继续用<strong>盗梦空间</strong>的话题比喻最为合适；</p><p>当我们进入第三层梦的时候，小李子终于修正了富二代费舍的思想，这个时候，需要就需要回归主干，进行<strong>合并</strong>了；</p><p>当然在主干中的行为，修正一些bug，也可以及时的合并到分支上来，也可以想像一下小李子的第二层梦对他第三层梦的影响，在合并的影响下传递到了第三层梦中了。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>学过编程的都知道，加锁，在编程中加锁以后的线程，只能是单个线程访问，不能是多线程同时访问；</p><p>顾明思议，当两个人都要操作同一个源文件的时候，就像我要进房间，而又不允许别人进这个房间，那么我就选择<strong>加锁处理</strong>；</p><h4 id="严格加锁"><a href="#严格加锁" class="headerlink" title="严格加锁"></a>严格加锁</h4><p>被加锁的文件一开始都是<strong>只读</strong>状态，要编辑和修改必须征询项目仓库的同意，在没有其他人编辑同一个文件的时候，项目仓库就会授权给你，其他人这个时候要编辑，仓库就会拒绝；</p><h4 id="乐观加锁"><a href="#乐观加锁" class="headerlink" title="乐观加锁"></a>乐观加锁</h4><p>也就是当你进行签入的时候，项目仓库会先行更新你的本地文件，再让你进行签入；</p><p>但这个时候，版本控制系统不会简单的以项目仓库中最新版本的文件去覆盖你辛苦改过的文件，而是<strong>尝试着去合并项目仓库中所有的改动和你的改动</strong>；</p><p>一般而言严格加锁在使用过程中会出现很多问题，例如：一个人必须要等其他人编辑结束并签入之后才能继续他的工作；</p><p>因此用得更多的反而是乐观加锁处理；</p>]]></content>
      
      <categories>
          
          <category> 版本管理 </category>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVN </tag>
            
            <tag> 版本管理 </tag>
            
            <tag> 程序员必修三部曲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>习惯的力量</title>
      <link href="/2018/05/07/%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F/"/>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>人每天的活动中，有超过40%是习惯的产物，而不是自己主动决定的。</p></blockquote><p>开篇就引人入胜，一个人的工作时间是8小时一天，那么40%也就是3.2小时，接近一半的时间我们都是<strong>自动驾驶模式</strong></p><p>因此习惯就是我们需要挖掘的一个宝藏，<strong>用于提升工作效率，还是生活节奏，或者提升生活方式的不二选择。</strong></p><blockquote><p>我们每天做出的大部分选择似乎都是精心考虑的决策结果，其实不然。这些选择都是习惯的结果。</p></blockquote><p>每天清晨醒来，我知道大部分的人应该是和我一样，都是打开手机，然后刷一下，不管是刷新闻，还是刷微博或者朋友圈。</p><p>之前我一直没有思考早上起来第一瞬间，我该有的行为，只是顺应着。</p><p>但当我认真思考的时候，我发现，其实我还在睡觉，大脑深层次的本我并没有振作着醒来，而是使用<strong>自动驾驶模式</strong>；</p><p><strong>尽管我不想这样，但是这就是习惯。</strong></p><p><strong>既然习惯成为了我们手中，具有优先选择权的一项活动，那么我们没有理由不掌握它，为我们选择对的！</strong></p><h4 id="个体习惯"><a href="#个体习惯" class="headerlink" title="个体习惯"></a>个体习惯</h4><p>在我们认识到习惯给我们带来了巨大的影响，这个时候我们不得不沉思；</p><p>习惯到底怎么形成的呢？怎么就会变成了习惯？</p><p>如何改变创造自己认为对的习惯？</p><p>能成功么？是否有可行性呢？</p><h5 id="习惯的运作方式"><a href="#习惯的运作方式" class="headerlink" title="习惯的运作方式"></a>习惯的运作方式</h5><p>记忆是否真的很重要，哪一段记忆更重要？</p><p>科学家们，在通过对<strong>尤金-保利</strong>失去部分脑组织功能却任然能正常生活的行为研究之后；</p><p>发现了他虽然已经遗失了记忆，但<strong>在大脑深处，也就是脊柱和大脑结合的位置——基底核</strong>仍然在正常工作；</p><p>这部分组织控制着个人的<strong>自动行为</strong>，包括了比如呼吸和吞咽等行为；</p><p>在20世纪90年代，麻省理工的研究人员又针对<strong>基底核</strong>，采用老鼠穿越迷宫时候的脑活动研究，发现老鼠在熟悉路线以前，脑活动频繁，熟悉之后，快速前进大脑几乎没有活动；</p><p>这个过程被称为<strong>“组块化”</strong>，也就是大脑将一系列的行为变成一种自动的惯常行为，而这也是习惯形成的基础。</p><p>我们每天生活就靠这些行为组块（数量没有几百，也有几十），例如刷牙，穿衣服等。</p><p>发生这一现象的原因，科学家归结为：大脑一直在寻找可以省力的方式；</p><p><strong>因为习惯能让大脑得到更多的休息，这种省力的本能是一种大优势。</strong></p><p>这也就解释了，你走路的时候，不会想着先抬起左脚还是右脚，要抬多高的问题。</p><p>习惯是如何产生的。</p><p>这里我用一个大家较为熟悉概念来跟大家说明这个问题，当然其中如果有理解偏差的肯定会有，毕竟这是我消化吸收之后再加工的；</p><p><strong>电脑</strong>——大家都很熟悉的一个东西，电脑在设计之初有模范过人脑的部分功能，所以用电脑比喻一下人脑其实也算合适；</p><p>电脑在运行的时候，一些需要经常处理计算的程序是会被加载到内存里面；</p><p>而这套理论放到人的身上的时候，似乎也是很使用，人的很多行为都是习惯组成，所以最快速的，最平常的一些全部都被加载到身体的<strong>内存</strong>里了；</p><blockquote><p>在大部分的企业中，人们之间有一份心照不宣的默契，个人有野心是好的，但是你折腾过了头，你的同事会联合起来对付你。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 管理 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
            <tag> 习惯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本管理——重新认识版本管理</title>
      <link href="/2018/04/19/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<h4 id="为什么要重新认识？"><a href="#为什么要重新认识？" class="headerlink" title="为什么要重新认识？"></a>为什么要重新认识？</h4><p>我想大多数的人，在最开始的时候，进入编程这块以后，很快由别人带领之下使用了SVN、GIT等的版本管理工具；</p><p>对于如何使用，在多次练习的情况下，对与版本管理有了不小的心得；</p><p>更甚者已经是玩得飞起了，但是我要说的是，我不是，我只用了很多基础的功能，还有更多的东西等待我去挖掘；</p><p>但我相信很多人虽然对版本管理软件很熟悉，但是对于版本管理这个概念还是很陌生，不知道它的真正用处。</p><p>而没有学过的版本管理的人，那么这篇文章将带你认真了解版本管理；</p><h4 id="为什么要使用版本管理"><a href="#为什么要使用版本管理" class="headerlink" title="为什么要使用版本管理"></a>为什么要使用版本管理</h4><pre class=" language-txt"><code class="language-txt">需求第一版.md需求第二版.md需求第二版修改小部分.md需求第二版修改大部分.md需求第二版终极版.md需求究极版.md需求究极版再改.md</code></pre><p>请问，同志，上面的需求版本究竟有几个？他发布了几个？改动了多少？</p><p>这是一个很头疼的问题，你根本不清楚他的一个版本变化过程，在比较上也很困难（难道你一个个文件打开了进行比对？）</p><p>如果说究极版再改部分需要前面的第二版的某部分已经删除了，你是不是得一段段的查找？</p><p>你修改的时候不希望破坏掉修改前的状态，最好就是每修改一段事件，能够保存一个状态，类似系统的自动快照一样，当后面出现问题的时候，可以自由选择复原到之前的某个快照状态； <a href="https://www.cnblogs.com/newlifechou/p/8196395.html" target="_blank" rel="noopener">^博客园</a></p><p>还有一个原因，那就是，最后发布软件的时候很多时候会有多个版本，而生成软件的源代码却往往只有一份，只是在最后编译生成的时候用到不同的部分，大部分代码还是共用的，所以往往需要版本控制，几个版本复制几个文件夹出来； <a href="https://www.cnblogs.com/newlifechou/p/8196395.html" target="_blank" rel="noopener">^博客园</a></p><p>版本控制的过程也是过程追踪记录，成就达成的过程。 <a href="https://www.cnblogs.com/newlifechou/p/8196395.html" target="_blank" rel="noopener">^博客园</a></p><h5 id="标准定义-百度百科"><a href="#标准定义-百度百科" class="headerlink" title="标准定义^百度百科"></a>标准定义<a href="https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/2511538?fr=kg_qa" target="_blank" rel="noopener">^百度百科</a></h5><p>版本管理是为满足不同需求，对同一产品或系统进行局部的改进 和改型所产生的产品或系统系列的变更情况进行记录、跟 踪、维护和控制的过程。 </p><p>主要功能：</p><ol><li><strong>集中管理</strong>档案，安全授权机制：档案集中地存放在服务器上，经<strong>系统管理员</strong>授权给各个用户。用户通过check in和check out的方式访问服务器上的文件，未经授权的用户则无法访问服务器上的文件;</li><li>软件版本升级管理：每次登入时，在服务器上都会生成新的版本，任何版本都可以随时检出编辑;</li><li>加锁功能：在文件更新时保护文件，避免不同的用户更改同一文件时发生冲突;</li><li>提供不同版本源程序的比较;</li></ol><h5 id="使用定义-CSDN博客"><a href="#使用定义-CSDN博客" class="headerlink" title="使用定义^CSDN博客"></a>使用定义<a href="https://blog.csdn.net/cfj68583589/article/details/8523173" target="_blank" rel="noopener">^CSDN博客</a></h5><ol><li>数据备份；</li><li>版本管理，避免版本管理换乱</li><li>提高代码质量；</li><li>提高协同、多人开发的效率；</li><li>明确分工责任；</li></ol><p>既然知道了版本管理如此重要，那么大家又是使用什么方式进行版本管理的呢？</p><p>这就不得不提到的，版本管理发展历程；</p><h4 id="版本发展历程"><a href="#版本发展历程" class="headerlink" title="版本发展历程"></a>版本发展历程</h4><h5 id="手工帐"><a href="#手工帐" class="headerlink" title="手工帐"></a>手工帐</h5><p>最早的时候，我相信，还没有推出现有的版本管理工具的时候，使用的就是手工帐的方式，分别记录各个文件到了哪个版本；</p><p>其实就现有的版本工具而言，只能做到文本式的版本管理，而对应的二进制文件，或者其他的设计图片类文件，还无法使用版本管理工具进行管理；</p><p>只能是依然采用手工帐的方式，当然在计算机的软硬件发展的情况下，就算是手工帐也比之前的手工帐方便许多；</p><h5 id="早期VCS阶段-纵一苇"><a href="#早期VCS阶段-纵一苇" class="headerlink" title="早期VCS阶段^纵一苇"></a>早期VCS阶段<a href="https://www.cnblogs.com/zhangzl419/p/4280202.html" target="_blank" rel="noopener">^纵一苇</a></h5><p>这类系统要求系统的用户必须登录到版本库所在的服务器才能访问版本库。            </p><p>局限性：存在可扩展性方面的问题。</p><h5 id="集中式VCS阶段-纵一苇"><a href="#集中式VCS阶段-纵一苇" class="headerlink" title="集中式VCS阶段 ^纵一苇"></a>集中式VCS阶段 <a href="https://www.cnblogs.com/zhangzl419/p/4280202.html" target="_blank" rel="noopener">^纵一苇</a></h5><p>CVS和SVN解决上述早期版本控制工具的可扩展性问题。</p><p>这类版本控制工具允许程序员通过网络来获取版本库中的代码，并且在修改之后提交回来。</p><p>这类系统解决可扩展性问题是通过客户端来解决的，客户端可以有无数个，但是版本库所在的服务端也还是只有一个，客户端可以随意安装，这样就解决了可扩展性的问题。           </p><p>具体的使用方法：每一个程序员在本地有一个工作目录树，其内容是该版本库中最新的代码。当他们在工作目录树中完成代码修改之后，就把改动提交会该代码库。           </p><p>局限性：在本地工作目录树中只会看到代码的最新版本，如果想要查询历史修改记录，就必须与服务器上的版本库打交道。</p><p>这样要和远程的版本库打交道，就必须使用网络，但是即使今天的互联网处于永不断线的状态，有的时候还是不能上网。</p><p>所以分布式版本控制工具就解决了这个问题，以git为代表的分布式版本控制工具使每个用户在本地都有自己的版本库，而不是连接到公共服务器上的一个公共版本库中去。</p><h5 id="分布式版本控制工具阶段-纵一苇"><a href="#分布式版本控制工具阶段-纵一苇" class="headerlink" title="分布式版本控制工具阶段 ^纵一苇"></a>分布式版本控制工具阶段 <a href="https://www.cnblogs.com/zhangzl419/p/4280202.html" target="_blank" rel="noopener">^纵一苇</a></h5><p>所有的版本控制工具都存储在本地版本库中，向版本库提交代码无需链接远程版本库，所有的历史记录都存储在本地版本库中，向版本库提交代码无须连接远程版本库，而是所有的版本数据都存放在本地版本库中。          </p><p> 分布式版本控制工具程序员之间如何传递各自的修改，如何同步呢？程序员还是将修改上传到项目的主版本库中去。</p><p>有两种实现方式：</p><ol><li>通过git的push操作直接把修改上传到主版本库；</li><li>生成包含少量修改的补丁包，把补丁包提交给项目维护人员，再由项目维护人员更新主版本库。  </li></ol><p>如果想了解更多的，可以看看<a href="http://www.cnblogs.com/vamei/archive/2013/02/21/2918069.html" target="_blank" rel="noopener">版本管理三国志</a>，这篇博主对于版本管理有着更深刻的认识；</p><p>在知道这些以后，那么我们选择哪款软件，或者说选择什么样的管理方式呢？</p><h4 id="版本控制软件分类"><a href="#版本控制软件分类" class="headerlink" title="版本控制软件分类"></a>版本控制软件分类</h4><h5 id="集中式版本管理"><a href="#集中式版本管理" class="headerlink" title="集中式版本管理"></a>集中式版本管理</h5><p>集中式顾名思义就是代码集中到服务器，用的时候每个人把自己需要的被授权的那部分代码下载到自己的计算机上；</p><p>提交也是最后提交到服务器上，服务器可以对代码做很好的控制，但是需要有网络，网络断了，就没法工作了。  </p><p>代表就是SVN,Team Foundation等 </p><h5 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h5><p>分布式自然就是每个人的地方多有一份完全的代码，提交和管理都是在本地进行；</p><p>虽然有远端仓库，不过那是最终提交用的，没联网本地也是完整代码的，只是每次需要最新的代码的时候才必须联网；</p><p>分布式的代表就是git，对应的网上仓库比较有名的就是github. </p><hr><p>在清楚的了解这么多之后，我们就要落到实处了，那么究竟如何管理好我们手头上的代码，<strong>如何有效的进行版本管理呢</strong>？</p><p>我想这才是大家关心的重点，也是我为什么需要重新认识版本管理这个概念；</p><p>这里我先留个空，后面来填写这个坑，我会着重<strong>SVN</strong>,<strong>GIT</strong>这两个具有代表性的版本控制工具进行深入的了解和体会。</p>]]></content>
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
            <tag> 版本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>专注力管理-让你的努力更高效</title>
      <link href="/2018/04/17/%E4%B8%93%E6%B3%A8%E5%8A%9B%E7%AE%A1%E7%90%86-%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%8A%AA%E5%8A%9B%E6%9B%B4%E9%AB%98%E6%95%88/"/>
      <content type="html"><![CDATA[<h4 id="怎么接触到这本书的"><a href="#怎么接触到这本书的" class="headerlink" title="怎么接触到这本书的"></a>怎么接触到这本书的</h4><p>最开始的时候，我也不知道这本书，后面公司组织培训，然后有同事专门对这本书的内容进行了讲解；</p><p>我觉得是本难得的好书，里面干货多多，值得学习一番，或许此前我已经接触过类似，擦边的书籍，但是不妨碍自己再次反思一番；</p><h4 id="本书给我带来的体验"><a href="#本书给我带来的体验" class="headerlink" title="本书给我带来的体验"></a>本书给我带来的体验</h4><h5 id="努力得越多，越不明白"><a href="#努力得越多，越不明白" class="headerlink" title="努力得越多，越不明白"></a>努力得越多，越不明白</h5><p>接触这本书以后，顿时有种醍醐灌顶的感觉，或许很多时候，我其实有想过类似的问题，但是效果却一直不是很好；</p><p>套用书里面的话说，我投入了很多<strong>士兵</strong>（时间），但没有一个好的<strong>将军</strong>（专注力），导致于我失败了一次又一次的战役；</p><p>但这样的事情又每天都上演着，一直以为自己是努力不够，忘却了一个人一天最多有24h，就算压缩睡眠时间到6h，剩下的也就是18h，不可能比别人更多；</p><p>相信有的人一天只睡4-5h，那么是不是那堆人比自己更努力，更厉害了？</p><p>可是卖菜大妈一直都还是卖菜大妈，不管起的多早；</p><h5 id="努力-效果"><a href="#努力-效果" class="headerlink" title="努力!=效果"></a>努力!=效果</h5><p>我相信很多时候，我的行为不管在我自己，还是在别人看来我都是努力的，但是收到的<strong>效果</strong>，我却一直都不满意；</p><p>在和身边的很多同学比较一番之后，我发现了，<strong>我努力带来的结果，仅仅只是好上一点点，收效甚微</strong>；</p><p>仔细反省一番之后，<strong>诚如书中所说的那样，我有意无意的陷入了一种颇为讽刺的自我陶醉中</strong>；</p><p>而书里面给出了这样的一句话：<strong>努力的核心是专注</strong>；</p><p><img src="\img\articlePicture\AbsorbedStrive.jpg" alt="@努力！=走上人生巅峰"></p><p><strong>警惕自己的努力，它可能是无效的努力。</strong></p><p>这句话，简直是直击要害，如果严格点，很时候，你做的事情，一点价值都没有，完全否定了；</p><p>实际情况偏偏是这样，太多时候，如果没有经过认真反思，和专注的努力，最后的效果可以说跟没效果是没区别的；</p><h5 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h5><p>书籍里面将努力的<strong>瞄准</strong>定位到了<strong>专注力</strong>上面；</p><p>而围绕专注力收到的影响，归为了三类：</p><ul><li>目标</li><li>能力</li><li>心态</li></ul><p>在这三类的影响之下，很多人走神了，更夸张点的失神了，完全启动了<strong>自动驾驶模式</strong>；</p><p>根据这三点，又做再次的延伸，如何针对性的解决；</p><h4 id="是什么让我觉得这是本好书"><a href="#是什么让我觉得这是本好书" class="headerlink" title="是什么让我觉得这是本好书"></a>是什么让我觉得这是本好书</h4><h5 id="书短"><a href="#书短" class="headerlink" title="书短"></a>书短</h5><p>很奇怪，跟原来的印象不一样了，我们都知道很多的经典，都是很长的；</p><p>而且在我们的意识里面，我们会最先想到的是，读的书越厚，那么获取到的越多；</p><p>这样我就陷入了最早开始说的，陷入了一种没有效果的死循环；</p><p>真正有用，而且专注的必然不会太长，而需要消化的时间必然不是很短的一个过程；</p><h5 id="内容精简"><a href="#内容精简" class="headerlink" title="内容精简"></a>内容精简</h5><p>跟现在的书比起来，动不动就是各种方法，这本书的内容算少的；</p><p>或许因为少，所以这本书的定位，是一小时电子书；</p><p>让我们本身就专注在一小时内理解本书的用意和具体的操作方法；</p><h5 id="方法实用"><a href="#方法实用" class="headerlink" title="方法实用"></a>方法实用</h5><p>书里面推荐了一些方法，很多人之前其实都接触过；</p><p>例如现在较为流行的<strong>番茄工作法</strong>等；</p><blockquote><p>一小时你能做什么，如何让它更高效，这部书给你答案；</p></blockquote>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专注 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 高效 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>json与bson的区别</title>
      <link href="/2018/03/10/json%E4%B8%8Ebson%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>bson是由10gen开发的一个数据格式，目前主要用于mongoDB中，是mongoDB的数据存储格式。bson基于json格式，选择json进行改造的原因主要是json的通用性及json的schemaless(无模式)的特性。</p><h3 id="bson主要方向"><a href="#bson主要方向" class="headerlink" title="bson主要方向"></a>bson主要方向</h3><h4 id="更快的遍历速度"><a href="#更快的遍历速度" class="headerlink" title="更快的遍历速度"></a>更快的遍历速度</h4><p>对json格式来说，太大的json结构会导致数据遍历非常慢。在json中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配，比如括号的匹配。 </p><p>而bson对json的一大改进就是，它会将json的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。</p><h4 id="操作更简易"><a href="#操作更简易" class="headerlink" title="操作更简易"></a>操作更简易</h4><p>对json来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个，所以可能其后面的所有内容都需要往后移一位才可以。 </p><p>而使用bson，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改，不会导致数据总长变大。 </p><p>当然，在mongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。</p><h4 id="增加了额外的数据类型"><a href="#增加了额外的数据类型" class="headerlink" title="增加了额外的数据类型"></a>增加了额外的数据类型</h4><p>json是一个很方便的数据交换格式，但是其类型比较有限。 </p><p>bson在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成json，大大减少了计算开销和数据大小。 </p><p>当然，在有的时候，bson相对json来说也并没有空间上的优势，比如对{“field”:7}，在json的存储上7只使用了一个字节，而如果用bson，那就是至少4个字节（32位）</p><p>目前在10gen的努力下，bson已经有了针对多种语言的编码解码包。并且都是<em>Apache2 license</em>下开源的。并且还在随着mongoDB进一步地发展。</p><h3 id="json与bson对比"><a href="#json与bson对比" class="headerlink" title="json与bson对比"></a>json与bson对比</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>json是像<strong>字符串存储</strong>的，bson是按<strong>结构存储</strong>的（像数组 或者说struct）</p><h4 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h4><p>bson&gt;json</p><h4 id="操作速度"><a href="#操作速度" class="headerlink" title="操作速度"></a>操作速度</h4><p>bson&gt;json。比如，遍历查找：json需要扫字符串，而bson可以直接定位</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>json也要大动大移，bson就不需要。</p><p>在大多数情况下，JSON和BSON非常相似，但BSON可以提供额外的速度冲击。当然，两者都是应用程序存储和检索数据非常方便的方法。</p><blockquote><p>转自<a href="http://blog.csdn.net/xiaojin21cen/article/details/60953980" target="_blank" rel="noopener">张山的博客专栏</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 数据格式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> BSON </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB</title>
      <link href="/2018/03/10/MongoDB/"/>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近学习到React-Native，需要学习一下Facebook推出的f8app例子；</p><blockquote><p>MongoDB介绍</p></blockquote><p>MongoDB 是一个基于分布式文件存储的数据库。由<strong>C++语言编写</strong>。<strong>旨在为WEB</strong>应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB <strong>是一个介于关系数据库和非关系数据库之间的产品</strong>，是非关系数据库当中功能最丰富，最像关系数据库的(<em>听着像小品界最会唱歌的小沈阳</em>)。他支持的数据结构非常松散，是类似json的bson(<strong>Binary Serialized Document Format</strong>)<strong>是一种二进制形式的存储格式</strong>，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是他支持的查询语言非常强大，<strong>其语法有点类似于面向对象的查询语言</strong>，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>这里不得不说一下，其实他是NoSQL(NoSQL = Not Only SQL,意即“不仅仅是SQL”)数据库的一种。</p><p>扩展一下，HBase数据库也是NoSQL的一种。</p><blockquote><p>特点</p></blockquote><ol><li>支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li><li>文件存储格式为BSON（一种JSON的扩展）。<a href="http://blog.langaobai.top/2018/03/10/json与bson的区别/">JSON与BSON</a></li><li>可通过网络访问。</li></ol><p>此处抄于百度词条，如果有错，不要找我…</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>而其中需要用到MongDB，我下载的是3.6版本的，需要下载的请点击<a href="https://www.mongodb.com/download-center#atlas" target="_blank" rel="noopener">MongoDB</a></p><p>一路点击<kbd>Next</kbd>就可以了，当然前提是你知道你要安装在什么地方。</p><p>直达最后，安装界面提示你，可能要花些时间，但是这个时间很说不准，万一卡了呢，那么你只能关闭了，不过不要担心，下次开机的时候，其实你已经安装好了，不行你就再装一遍。</p><h3 id="API学习"><a href="#API学习" class="headerlink" title="API学习"></a>API学习</h3><p>安装好以后，我们就该学习了，<a href="https://docs.mongodb.com/" target="_blank" rel="noopener">MongoDB API</a></p><p>未完待续…</p>]]></content>
      
      <categories>
          
          <category> MongDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSON </tag>
            
            <tag> MongDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle常用命令</title>
      <link href="/2018/03/09/Oracle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<h3 id="Oracle表空间创建"><a href="#Oracle表空间创建" class="headerlink" title="Oracle表空间创建"></a>Oracle表空间创建</h3><ol><li>创建临时表空间<pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">temporary</span> <span class="token keyword">tablespace</span> YNMZCK_TEMP  tempfile <span class="token string">'D:\Install_file\app\Administrator\oradata\orcl\YNMZCK_TEMP.dbf'</span> size 50m  autoextend <span class="token keyword">on</span>  <span class="token keyword">next</span> 50m maxsize 20480m  extent management <span class="token keyword">local</span><span class="token punctuation">;</span></code></pre></li><li>创建数据表空间<pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">tablespace</span> YNMZCK  logging  datafile <span class="token string">'D:\Install_file\app\Administrator\oradata\orcl\YNMZCK.dbf'</span> size 50m  autoextend <span class="token keyword">on</span>  <span class="token keyword">next</span> 50m maxsize 20480m  extent management <span class="token keyword">local</span><span class="token punctuation">;</span></code></pre></li><li><p>创建用户并指定表空间</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">user</span> YNMZCK identified <span class="token keyword">by</span> YNMZCK<span class="token keyword">default</span> <span class="token keyword">tablespace</span> YNMZCK  <span class="token keyword">temporary</span> <span class="token keyword">tablespace</span> YNMZCK_TEMP<span class="token punctuation">;</span></code></pre></li><li><p>给用户授予权限</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">connect</span><span class="token punctuation">,</span>resource<span class="token punctuation">,</span><span class="token number">dba</span> <span class="token keyword">to</span> YNMZCK<span class="token punctuation">;</span></code></pre></li></ol><h3 id="Oracle导入-导出dmp"><a href="#Oracle导入-导出dmp" class="headerlink" title="Oracle导入/导出dmp"></a>Oracle导入/导出dmp</h3><ol><li><p>导出命令</p><pre class=" language-bash"><code class="language-bash">exp YNMZCC/YNMZCC@orcl  file<span class="token operator">=</span>d:\ynmzcc.dmp owner <span class="token operator">=</span> YNMZCC</code></pre></li><li><p>导入命令</p><pre class=" language-bash"><code class="language-bash">imp username/password@SID file<span class="token operator">=</span>XXX.dmp fromuser<span class="token operator">=</span>XXX touser<span class="token operator">=</span>XXX tables<span class="token operator">=</span><span class="token punctuation">(</span>XXX,XXX<span class="token punctuation">)</span></code></pre></li></ol><h3 id="Oracle清空或者删除当前用户下所有的表"><a href="#Oracle清空或者删除当前用户下所有的表" class="headerlink" title="Oracle清空或者删除当前用户下所有的表"></a>Oracle清空或者删除当前用户下所有的表</h3><ol><li>使用客户端</li></ol><pre class=" language-bash"><code class="language-bash">使用pl/sql客户端，使用该用户登录，选中所有表 右键drop即可</code></pre><ol><li>动态生成删除命令（<strong>要求用户有相应权限</strong>）</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token string">'drop table '</span><span class="token operator">||</span>table_name<span class="token operator">||</span><span class="token string">';'</span> <span class="token keyword">from</span> user_tables<span class="token punctuation">;</span>  </code></pre><ol><li>使用存储过程删除该用户下所有表</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> ECHO <span class="token keyword">ON</span>  <span class="token keyword">set</span> define <span class="token keyword">off</span>       SPOOL logs<span class="token operator">/</span>create_procedure<span class="token punctuation">.</span>log  <span class="token comment" spellcheck="true">--删除所有表的存储过程;    </span><span class="token keyword">create</span> <span class="token operator">or</span> replace <span class="token keyword">procedure</span> P_DROP_ALL_TABLE  <span class="token keyword">as</span>     <span class="token comment" spellcheck="true">--引用user_tables表中的tableName的类型;  </span>  tableName user_tables<span class="token punctuation">.</span>table_name<span class="token operator">%</span><span class="token keyword">type</span><span class="token punctuation">;</span>      <span class="token keyword">type</span> ty <span class="token operator">is</span> record<span class="token punctuation">(</span>table_name varchar2<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--定义ref类型游标;-强类型  </span>  <span class="token keyword">type</span> ref_type <span class="token operator">is</span> ref <span class="token keyword">cursor</span> <span class="token keyword">return</span> ty<span class="token punctuation">;</span>    ref_t ref_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--定义变量存储数量;  </span>  mycount number<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">begin</span>      <span class="token comment" spellcheck="true">--打开游标;  </span>    <span class="token keyword">open</span> ref_t <span class="token keyword">for</span> <span class="token keyword">select</span> table_name <span class="token keyword">from</span> user_tables<span class="token punctuation">;</span>           loop               <span class="token comment" spellcheck="true">--从游标中获取一条记录,放入变量中;  </span>             <span class="token keyword">fetch</span> ref_t <span class="token keyword">into</span> tableName<span class="token punctuation">;</span>                      <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> mycount <span class="token keyword">FROM</span> user_tables <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> tableName<span class="token punctuation">;</span>                      <span class="token keyword">if</span> mycount<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">then</span>                         <span class="token keyword">execute</span> immediate <span class="token string">'DROP TABLE '</span><span class="token operator">||</span>tableName <span class="token operator">||</span> <span class="token string">' CASCADE CONSTRAINT '</span><span class="token punctuation">;</span>                      <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>               <span class="token keyword">exit</span> <span class="token keyword">when</span> ref_t<span class="token operator">%</span>notfound<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--退出;  </span>         <span class="token keyword">end</span> loop<span class="token punctuation">;</span>       <span class="token keyword">close</span> ref_t<span class="token punctuation">;</span>        <span class="token keyword">end</span><span class="token punctuation">;</span>  <span class="token operator">/</span>  </code></pre><p>清除的话，将 <strong>drop</strong> 替换为 <strong>truncate</strong> 或者 <strong>delete</strong> ,过程 同上</p><h3 id="如何使用sql语句操作表中的字段"><a href="#如何使用sql语句操作表中的字段" class="headerlink" title="如何使用sql语句操作表中的字段"></a>如何使用sql语句操作表中的字段</h3><ol><li>新增字段</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 时间字段 <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> SYSDATE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 新增</span><span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">COLUMN</span> 表名<span class="token punctuation">.</span>时间字段 <span class="token operator">IS</span> <span class="token string">'系统时间'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span></code></pre><ol><li>修改字段</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 要修改的字段 VARCHAR2（<span class="token number">12</span>）<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 修改</span><span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">COLUMN</span> 表名<span class="token punctuation">.</span>要修改的字段 <span class="token operator">IS</span> <span class="token string">'系统时间'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span></code></pre><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h3><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">user</span> 用户名称 <span class="token keyword">cascade</span><span class="token punctuation">;</span></code></pre><h4 id="删除表空间-1"><a href="#删除表空间-1" class="headerlink" title="删除表空间"></a>删除表空间</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">tablespace</span> 表空间名称 including contents <span class="token operator">and</span> datafiles <span class="token keyword">cascade</span> <span class="token keyword">constraint</span><span class="token punctuation">;</span></code></pre><h3 id="根据表相关信息进行查询"><a href="#根据表相关信息进行查询" class="headerlink" title="根据表相关信息进行查询"></a>根据表相关信息进行查询</h3><h4 id="根据表信息查询表"><a href="#根据表信息查询表" class="headerlink" title="根据表信息查询表"></a>根据表信息查询表</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- UTC可接字段</span><span class="token comment" spellcheck="true">-- TABLE_NAME 表名</span><span class="token comment" spellcheck="true">-- TABLE_TYPE 表类型</span><span class="token comment" spellcheck="true">-- COMMENTS 注释</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> USER_TAB_COMMENTS UTC <span class="token keyword">WHERE</span> UTC<span class="token punctuation">.</span>COMMENTS <span class="token operator">LIKE</span> <span class="token string">'%comment%'</span></code></pre><h4 id="根据表字段查询"><a href="#根据表字段查询" class="headerlink" title="根据表字段查询"></a>根据表字段查询</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- TABLE_NAME 表名</span><span class="token comment" spellcheck="true">-- COLUMN_NAME 字段名称</span><span class="token comment" spellcheck="true">-- COMMENTS 字段注释</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> USER_COL_COMMENTS <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'TABLE_NAME'</span></code></pre>]]></content>
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MODBUS协议</title>
      <link href="/2018/03/09/MODBUS%E5%8D%8F%E8%AE%AE/"/>
      <content type="html"><![CDATA[<h4 id="情况介绍"><a href="#情况介绍" class="headerlink" title="情况介绍"></a>情况介绍</h4><p>最近公司项目有部分涉及到一个库位灯的通讯，因此我需要对该协议有个具体的了解；</p><p>在之前我并没有接触过这个协议甚至不明白这是啥，能用来做啥的。</p><p>我们首先对<strong>协议</strong>这个特定的词汇进行深入解读一下，避免一些语文差点的同学搞不清楚；</p><p>如果需要对这个汉语有更深入的了解，可以百度一下；</p><p>我们这里用自己的话说一下，其实就是方言，例如你说温州话，或者英语，而你也只能听懂这类话，我们因此把这种说温州话或者英语的标准称为协议。</p><p>上面我们说了一堆废话，那么从下面开始，我们进入正题；</p><p>我们需要与库位灯进行沟通，那么就需要一种方言——<em>协议</em>。</p><p>就让我们了解下什么是MODBUS协议；</p><h4 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h4><p><strong>Modbus 是一个请求/应答协议。</strong></p><p><strong>它已经成为一通用工业标准。有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。</strong></p><p>MODBUS协议支持传统的RS-232、RS-422、RS-485和以太网设备。许多工业设备，包括PLC，DCS，智能仪表等都在使用Modbus协议作为他们之间的通讯标准。</p><p>MODBUS通讯协议，是1979年由美国Modicon 公司提出的，就是被称为PLC 之父的迪克·莫利先生创造的品牌。</p><p><strong>MODBUS是世界上第一个用于工业现场的总线协议</strong>，可以说，它的出现标志着工业现场从模拟量时代向通讯时代迈进。。</p><h4 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h4><p>既然是协议，那么它究竟如何定义，它的规范又是什么呢？</p><p>从程序的角度出发，快速定义：</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><h5 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h5><p>安装modbus仿真工具<a href="http://www.modbustools.com/download.html" target="_blank" rel="noopener">Modbus Slave</a>, 用来模仿一台Modbus协议设备</p><p>1.安装完毕之后的界面是这样的：</p><p><img src="\img\articlePicture\ModbusSlaveIcon.png" alt="安装好之后的样子"></p><p>2.启动后的界面：</p><p><img src="\img\articlePicture\ModbusSlaveLunch.png" alt="启动之后的样子"></p><p>3.选中仿真的设备，然后进行设定，或者鼠标点击按<strong>F8</strong></p><p><img src="\img\articlePicture\ModbusSlaveOperat.png" alt="启动之后的样子"></p><p>4.这里我参考了别人对于Function的理解</p><p>4.1 个人理解版本</p><ul><li>可以读写的布尔类型(0x)</li><li>只能读的布尔类型(1x)</li><li>只能读的数字类型(3x)</li><li>可以读写的数字类型(4x)</li></ul><p>4.2 jamod也提供了操作每种不同类型使用不同的类，这里我列个表</p><table><thead><tr><th>类型</th><th>请求类</th><th>响应类</th></tr></thead><tbody><tr><td>可以读写的布尔类型(0x)</td><td>ReadCoilsRequest</td><td>ReadCoilsResponse</td></tr><tr><td>只能读的布尔类型(1x)</td><td>ReadInputDiscretesRequest</td><td>ReadInputDiscretesResponse</td></tr><tr><td>只能读的数字类型(3x)</td><td>ReadInputRegistersRequest</td><td>ReadInputRegistersResponse</td></tr><tr><td>可以读写的数字类型(4x)</td><td>ReadMultipleRegistersRequest</td><td>ReadMultipleRegistersResponse</td></tr></tbody></table><p>5.设定成功以后选择上部的菜单<kbd>Connection</kbd>，选择<strong>Modebus TCP/IP</strong>，在<strong>TCP/IP Server</strong>栏进行进行配置，如图</p><p><img src="\img\articlePicture\ModbusSlaveConnect.png" alt="Modbus Connect"></p><p>启动之后，红色的No Connection就会消失了；</p><h5 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h5><p>如果你使用的也是java，好吧，这里仅仅介绍java的，其他另外想办法吧。</p><p>可以到maven仓库去下载这个<a href="http://mvnrepository.com/artifact/net.wimpi/jamod/1.2" target="_blank" rel="noopener">jamod.jar</a></p><h5 id="java编程部分-源码"><a href="#java编程部分-源码" class="headerlink" title="java编程部分^源码"></a>java编程部分<a href="详细的可以从GitHub上下载源代码,具体见文章最后">^源码</a></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ModbusUtil</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * @Title: readDigitalInput     * @Description: TODO(只能读的布尔类型(1x))     * @autor hongpeng.zhang    * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readDigitalInput</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: readInputRegister     * @Description: TODO(只能读的数字类型(3x))     * @autor hongpeng.zhang    * @param ip IP地址    * @param port 端口    * @param address 内部寄存器地址，PLC地址    * @param slaveId modbus设备地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readInputRegister</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: readDigitalOutput     * @Description: TODO(可以读写的布尔类型(0x))     * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readDigitalOutput</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: readRegister     * @Description: TODO(读取可以读写的数字类型(4x))     * @autor hongpeng.zhang    * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readRegister</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span><span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: writeRegister     * @Description: TODO(写入数据到真机，数据类型是RE,用于写到寄存器地址，相应数据，这里需要注意的是，针对的设备必须是可以读写的数字类型，而非另外三种)     * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @param value 需要设置的值    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeRegister</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: writeDigitalOutput     * @Description: TODO(写入数据到真机的DO类型的寄存器上面)     * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @param value 需要设置的值    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeDigitalOutput</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>上面的部分引自<strong>核心代码</strong>部分，需要直接操作的，可以直接找到这个类，我已经对照进行注释了；</p><p>内部使用的变量字符都可以对照着模拟仿真对应的设置参数；</p><blockquote><p>本文中的代码部分，以及代码操作部分引 <a href="https://www.cnblogs.com/Dn9x/p/4298146.html" target="_blank" rel="noopener">Dn9x</a> <a href="https://github.com/Dn9x/dn-modbus" target="_blank" rel="noopener">GitHub地址</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> MODBUS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MODBUS </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello,大家好，这是我在git上开通的博客</title>
      <link href="/2016/09/22/hello-%E5%A4%A7%E5%AE%B6%E5%A5%BD%EF%BC%8C%E8%BF%99%E6%98%AF%E6%88%91%E5%9C%A8git%E4%B8%8A%E5%BC%80%E9%80%9A%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p>这里采用了<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>作为搭建工具</p><p>具体的演示内容就不在这进行多余的叙述，搭建的过程也是困难重重。</p><p>一开始就遇到一个问题，不论如何都是不对，后面根据知乎里面一个大神的解答，终于能够顺利发布版本进行更新。</p><blockquote><p>以下是那位大神的解答</p></blockquote><pre class=" language-bash"><code class="language-bash">首先清空 $ hexo clean然后在你建立的博客文件夹下删除.deploy_git$ <span class="token function">git</span> config --global core.autocrlf <span class="token boolean">false</span>重新导出：$ hexo g发布版本: $ hexo d</code></pre><p><em>这里的3，代表的意思是配置git的全局变量，关闭它的自动换行功能，当然了，针对其中的工作原理可以选择使用其他的配置方式，不一定要采用关闭的方式。</em></p><hr><p><strong>至于其他的初始化，如何进行配置等，这里不做详细指导</strong><br>各位可以通过百度或者谷歌就能找到答案；</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/baidu_verify_UJnzbcntPV.html"/>
      <content type="html"><![CDATA[UJnzbcntPV]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<blockquote><p>蓝告白的博客，langaobai‘s blog’</p></blockquote><p>俗话说的好，<strong>好记性不如烂笔头</strong>，这是我的个人博客；</p><p>一直以来都没有好好记录和整理一下关于自己的东西；</p><p>原来建立博客的时候还是两年前的事情了，但直到最近才发现自己很多时候，<strong>没有记录，意味着自己没有好好沉淀属于自己的东西。</strong></p><p>博客会记录关于三个方面的东西，<strong>IT技术</strong>，<strong>书籍</strong>，<strong>电影</strong></p>]]></content>
    </entry>
    
    <entry>
      <title>走廊</title>
      <link href="/gallery/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签云</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>时间桥</title>
      <link href="/timeline/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
