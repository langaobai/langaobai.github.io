<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CCF-201312</title>
      <link href="/2018/11/16/CCF-201312/"/>
      <content type="html"><![CDATA[<p>欲解题，先解意，所以根据实际考试的经验，我必须要理解透彻题目的意思。</p><h2 id="出现次数最多的数"><a href="#出现次数最多的数" class="headerlink" title="出现次数最多的数"></a>出现次数最多的数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><table><thead><tr><th>试题编号：</th><th>201312-1</th></tr></thead><tbody><tr><td>试题名称：</td><td>出现次数最多的数</td></tr><tr><td>时间限制：</td><td>1.0s</td></tr><tr><td>内存限制：</td><td>256.0MB</td></tr><tr><td>问题描述：</td><td><strong>问题描述</strong><br>　　给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。<br><strong>输入格式</strong><br>　　输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 <br>　　输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。<br><strong>输出格式</strong><br>　　输出这n个次数中出现次数最多的数。<br>       如果这样的数有多个，输出其中最小的一个。<br>样例输入<br>       6 10 1 10 20 30 20<br>样例输出<br>       10</td></tr></tbody></table><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>输入：一行：输入的<strong>个数</strong></p><p>输入：二行：输入<strong>具体整数</strong></p><p>输出其中出现<strong>最多且最小的数</strong></p><p>使用HashMap记录数据，这样可以剔除重复数据；</p><p>在使用的过程中，key作为记录该整数值，Value作为记录这个整数出现的次数；</p><p>循环HashMap，获取最大Value值；</p><p>再循环一次HashMap,根据最大Value值中出现Key最小的值；</p><p>上面两次循环为了避免出现相同Value的情况下，获取到最小Key；</p><p>此题考察的很<strong>基础</strong>，算是考察到了算法中的<strong>数据结构</strong></p></blockquote><h3 id="解题源码"><a href="#解题源码" class="headerlink" title="解题源码"></a>解题源码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @ProjectName algorithm * @TypeDesc 输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个 * @TypeName MostNumber      */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MostNumber</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">MostNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> has <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> numb <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>has<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>numb<span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> count <span class="token operator">=</span> has<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>numb<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                has<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>numb<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                has<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>numb<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> minNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> en<span class="token operator">:</span>has<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>max<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> max<span class="token operator">&lt;</span>en<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> en<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> en<span class="token operator">:</span>has<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>max<span class="token operator">==</span>en<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>minNum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> minNum <span class="token operator">></span> en<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minNum <span class="token operator">=</span> en<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="评测结果"><a href="#评测结果" class="headerlink" title="评测结果"></a>评测结果</h3><table><thead><tr><th>试题名称</th><th>代码长度</th><th>编程语言</th><th>评测结果</th><th>得分</th><th>时间使用</th></tr></thead><tbody><tr><td>出现次数最多的数</td><td>922B</td><td>JAVA</td><td>正确</td><td>100</td><td>218ms</td></tr></tbody></table><h2 id="ISBN号码"><a href="#ISBN号码" class="headerlink" title="ISBN号码"></a>ISBN号码</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><table><thead><tr><th>试题编号：</th><th>201312-2</th></tr></thead><tbody><tr><td>试题名称：</td><td>ISBN号码</td></tr><tr><td>时间限制：</td><td>1.0s</td></tr><tr><td>内存限制：</td><td>256.0MB</td></tr><tr><td>问题描述：</td><td><strong>问题描述</strong><br>　　每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。<br> 　　识别码的计算方法如下：<br> 　　首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。<br> 　　编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。<br><strong>输入格式</strong><br>　　输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。输出格式<br>　　输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。<br><strong>样例输入</strong><br>         0-670-82162-4<br><strong>样例输出</strong><br>         Right<br><strong>样例输入</strong><br>         0-670-82162-0<br><strong>样例输出</strong><br>         0-670-82162-4</td></tr></tbody></table><h3 id="解提思路"><a href="#解提思路" class="headerlink" title="解提思路"></a>解提思路</h3><h3 id="解题源码-1"><a href="#解题源码-1" class="headerlink" title="解题源码"></a>解题源码</h3><h3 id="评测结果-1"><a href="#评测结果-1" class="headerlink" title="评测结果"></a>评测结果</h3><h2 id="最大的矩形"><a href="#最大的矩形" class="headerlink" title="最大的矩形"></a>最大的矩形</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><table><thead><tr><th>试题编号：</th><th>201312-3</th></tr></thead><tbody><tr><td>试题名称：</td><td>最大的矩形</td></tr><tr><td>时间限制：</td><td>1.0s</td></tr><tr><td>内存限制：</td><td>256.0MB</td></tr><tr><td>问题描述：</td><td><strong>问题描述</strong><br>　　在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。<br>这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。   <img src="http://118.190.20.162/RequireFile.do?fid=Fmhrjgtb" alt="img"><br>请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。<br> <img src="http://118.190.20.162/RequireFile.do?fid=gNe4DHhD" alt="img"><br><strong>输入格式</strong><br>　　第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。 <br>　　第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。<br><strong>输出格式</strong><br>　　输出一行，包含一个整数，即给定直方图内的最大矩形的面积。<br><strong>样例输入</strong><br>       6 3 1 6 5 2 3<br><strong>样例输出</strong><br>       10</td></tr></tbody></table><h3 id="解提思路-1"><a href="#解提思路-1" class="headerlink" title="解提思路"></a>解提思路</h3><h3 id="解题源码-2"><a href="#解题源码-2" class="headerlink" title="解题源码"></a>解题源码</h3><h3 id="评测结果-2"><a href="#评测结果-2" class="headerlink" title="评测结果"></a>评测结果</h3><h2 id="有趣的数"><a href="#有趣的数" class="headerlink" title="有趣的数"></a>有趣的数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><table><thead><tr><th>试题编号：</th><th>201312-4</th></tr></thead><tbody><tr><td>试题名称：</td><td>有趣的数</td></tr><tr><td>时间限制：</td><td>1.0s</td></tr><tr><td>内存限制：</td><td>256.0MB</td></tr><tr><td>问题描述：</td><td><strong>问题描述</strong><br>　　我们把一个数称为有趣的，当且仅当：<br> 　　1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。<br> 　　2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。<br> 　　3. 最高位数字不为0。<br> 　　因此，符合我们定义的最小的有趣的数是2013。<br>        除此以外，4位的有趣的数还有两个：2031和2301。<br> 　　请计算恰好有n位的有趣的数的个数。<br>        由于答案可能非常大，只需要输出答案除以1000000007的余数。<br><strong>输入格式</strong><br>　　输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。<br><strong>输出格式</strong><br>　　输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。<br><strong>样例输入</strong><br>        4<br><strong>样例输出</strong><br>        3</td></tr></tbody></table><h3 id="解提思路-2"><a href="#解提思路-2" class="headerlink" title="解提思路"></a>解提思路</h3><h3 id="解题源码-3"><a href="#解题源码-3" class="headerlink" title="解题源码"></a>解题源码</h3><h3 id="评测结果-3"><a href="#评测结果-3" class="headerlink" title="评测结果"></a>评测结果</h3><h2 id="I’m-stuck"><a href="#I’m-stuck" class="headerlink" title="I’m stuck!"></a>I’m stuck!</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><table><thead><tr><th>试题编号：</th><th>201312-5</th></tr></thead><tbody><tr><td>试题名称：</td><td>I’m stuck!</td></tr><tr><td>时间限制：</td><td>1.0s</td></tr><tr><td>内存限制：</td><td>256.0MB</td></tr><tr><td>问题描述：</td><td><strong>问题描述</strong><br>　　给定一个R行C列的地图，地图的每一个方格可能是’#’, ‘+’, ‘-‘, ‘\</td><td>‘, ‘.’, ‘S’, ‘T’七个字符中的一个，分别表示如下意思：<br> 　　‘#’: 任何时候玩家都不能移动到此方格；<br> 　　‘+’: 当玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非’#’方格移动一格； 　　‘-‘: 当玩家到达这一方格后，下一步可以向左右两个方向相邻的一个非’#’方格移动一格；<br> 　　‘\</td><td>‘: 当玩家到达这一方格后，下一步可以向上下两个方向相邻的一个非’#’方格移动一格； <br>　　‘.’: 当玩家到达这一方格后，下一步只能向下移动一格。如果下面相邻的方格为’#’，则玩家不能再移动； <br>　　‘S’: 玩家的初始位置，地图中只会有一个初始位置。玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非’#’方格移动一格；<br> 　　‘T’: 玩家的目标位置，地图中只会有一个目标位置。玩家到达这一方格后，可以选择完成任务，也可以选择不完成任务继续移动。<br>         如果继续移动下一步可以向上下左右四个方向相邻的任意一个非’#’方格移动一格。此外，玩家不能移动出地图。<br> 　　请找出满足下面两个性质的方格个数：<br> 　　1. 玩家可以从初始位置移动到此方格；<br> 　　2. 玩家<strong>不</strong>可以从此方格移动到目标位置。<br><strong>输入格式</strong><br>　　输入的第一行包括两个整数R 和C，分别表示地图的行和列数。(1 ≤ R, C ≤ 50)。<br>　　接下来的R行每行都包含C个字符。它们表示地图的格子。地图上恰好有一个’S’和一个’T’。<br><strong>输出格式</strong><br>　　如果玩家在初始位置就已经不能到达终点了，就输出“I’m stuck!”（不含双引号）。否则的话，输出满足性质的方格的个数。<br><strong>样例输入</strong><br>     5 5<br>     –+-+<br>     ..\</td><td>#.<br>     ..\</td><td>##<br>     S-+-T<br>     ####.<br><strong>样例输出</strong><br>        2<br><strong>样例说明</strong><br>　　如果把满足性质的方格在地图上用’X’标记出来的话，地图如下所示：<br> 　　–+-+<br>　　..\</td><td>#X <br>　　..\</td><td>## <br>　　S-+-T <br>　　####X</td></tr></tbody></table><h3 id="解提思路-3"><a href="#解提思路-3" class="headerlink" title="解提思路"></a>解提思路</h3><h3 id="解题源码-4"><a href="#解题源码-4" class="headerlink" title="解题源码"></a>解题源码</h3><h3 id="评测结果-4"><a href="#评测结果-4" class="headerlink" title="评测结果"></a>评测结果</h3>]]></content>
      
      <categories>
          
          <category> CCF </category>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 总结 </tag>
            
            <tag> CCF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CCF之傷</title>
      <link href="/2018/11/15/CCF%E4%B9%8B%E5%82%B7/"/>
      <content type="html"><![CDATA[<p>考试已经过去一段时间了，但是每每想起自己的分数，就觉得不应该忘记这种事情。</p><p>虽然在那段时间里面确实有好多事情干扰着，但是不能作为一个非标准的IT从业者所应该发生的事情。</p><p>先上一段总结吧。</p><h3 id="考前的准备情况"><a href="#考前的准备情况" class="headerlink" title="考前的准备情况"></a>考前的准备情况</h3><h4 id="学习的时间安排："><a href="#学习的时间安排：" class="headerlink" title="学习的时间安排："></a>学习的时间安排：</h4><p>未能充分重视这场考试，且开始做题的时候，较为轻松，略估分数觉得还能胜任，因此没有充分的重视起来；</p><p>因觉得提前练习不会让自己状态发挥到最好且在接到考试通知的时候有一个月忙于项目上的事情；</p><p>因此，在第二个月后，开始进行一些逐步的学习，仅在考前的半个月里面开始进行题目练习；</p><p><strong>时间安排：15天</strong></p><h4 id="时长及练习的方式："><a href="#时长及练习的方式：" class="headerlink" title="时长及练习的方式："></a>时长及练习的方式：</h4><p>开始的时候，完全没有找到感觉不知道怎么进行练习；</p><p>后面逐渐掌握方式，于是开始进行认真的摸索练习；</p><p><strong>时长：15天*2h</strong></p><p>方式：逐步的进行摸索以后，开始知道做题的重要性，在做题的过程中，一般我都是按照CCF官网给定的练习进行测试，满分一次通过，如果不是满分，则进行充分的分析以及测试；</p><h4 id="练习的题量："><a href="#练习的题量：" class="headerlink" title="练习的题量："></a>练习的题量：</h4><p><strong>15题</strong></p><h4 id="练习结果的跟进："><a href="#练习结果的跟进：" class="headerlink" title="练习结果的跟进："></a>练习结果的跟进：</h4><p>基本上是满分，所以没有太跟进题目的学习，仅仅针对一些复杂的图论算法进行跟进学习；</p><h3 id="对考试的整体评价和结果的反思"><a href="#对考试的整体评价和结果的反思" class="headerlink" title="对考试的整体评价和结果的反思"></a>对考试的整体评价和结果的反思</h3><p>考试内容的难易程度及题目理解、考试做题的经验、考试编程与实际工作的关联性及对实际工作的参考意义、个人的认识与反思。</p><h4 id="难易程度及题目理解："><a href="#难易程度及题目理解：" class="headerlink" title="难易程度及题目理解："></a>难易程度及题目理解：</h4><p>CCF的考试对与算法有一定的考校，题目由1-5难度逐渐加深。</p><p>1、2题需要在1小时内完成，剩下的3题也必须每题1小时的时间，当然前面的题越快做完越好；</p><p>3题还好，只是麻烦一些，到了4、5题的时候，感觉已经达到了赛事难度；</p><p>题目倒是能很好理解，但很多时候可能也因为自己的理解不到，所以在编写程序的时候，犯了一些致命错误因此在对给定例子的测试的时候通过了后，就没有进一步的测试；</p><p>在下来看到分数以后，我认真反思了自己做题过程中的思考方式，因当时环境问题，造成了我做题时候的心态偏急，题目在自己刚好理解以后就马上着手写程序，而没有在充分分析以后才来动手，这也是一个致命的问题；</p><h4 id="考试做题的经验："><a href="#考试做题的经验：" class="headerlink" title="考试做题的经验："></a>考试做题的经验：</h4><h4 id="参考意义："><a href="#参考意义：" class="headerlink" title="参考意义："></a>参考意义：</h4><p>与实际工作的关联系不大，因本人在公司工作的业务方向非大数据、云计算、人工智能、区块链等，而是政府行业。</p><p>因而对于特定的算法有要求的地方几乎没有，基本只是对业务的准确理解以及解析，实现；</p><p>但不能完全说没有用，因为基础的一些算法对于一些数据量大的查询还是非常有用的。</p><p>而且对于<strong>程序的理解程度可以进一步加强</strong>。</p><p>当然如果后期逐步像上面说到几个方向开展业务的话，关联性还是非常强的。</p><h4 id="认识："><a href="#认识：" class="headerlink" title="认识："></a>认识：</h4><p>通过这次考试，觉得算法挺有意思的，虽然在大学的时候，课程有系统的讲解，但那个时候对于这块认识度不够；</p><p>在后面过程中，我也培养了对于算法方面的兴趣，不在一味执着于新技术和技巧，而对于自己的基础应当重新翻查一遍巩固自己的地基；</p><p>也通过自己这次考试，对于自己在程序上面的理解瓶颈有了一定的突破，找到了一定的学习方向和思维方式；</p><h4 id="结果反思："><a href="#结果反思：" class="headerlink" title="结果反思："></a>结果反思：</h4><p>看到分数的时候我觉得很不可思议。</p><p>因本人在平时的练习过程中，在官网做完的题目几乎以100分的满分通过，就算再少也有40分，但是这已经很少了；</p><p>考试环境中虽然没有及时的给出分数，按照平时的检测结果不该这样。</p><p>后面逐渐反思，因为测试量的不足，虽然本人在做完题目以后均有对所有给定的例子进行测试，均已通过测试。</p><p>但最后发现，如果是这样的分数，那么说明在边界值的测试上面还不够，因而仅仅只获得了这个分数；</p><p>当然更多的应该归结于自己对于算法类型题目的练习量不够，之前我的总结我一直以为是自己做题和练题上面有问题；</p><p>但当我回过去看我自己的练习量的时候，我发现当我还在做CCF的时候，公司同事已经在做公司给定的题目了，对于自己对这场考试没有足够的重视，我本身也是要进行深刻反省的。</p><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>考试虽然考过了，但是后面的学习任重道远，不能仅仅止步于考完以后的总结就完了。</p><p>当然我个人的建议是：可以重视这种考试，但更多因采取学习的态度；</p><p>如果仅仅针对于考试，那么我的建议是<strong>练习量</strong>，以及掌握<strong>准确的测试</strong>这就够了；</p><p>如果是针对于自己的提高方面，那么光是练习完全不够的；</p><p>所以针对这个事情，我决定自己一定要狂垦 <strong>算法导论</strong>，然后把之前的失地，全部一一收复。</p><p>后期会持续跟进一些算法的题目，然后进一步的分析理解。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> CCF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 总结 </tag>
            
            <tag> CCF </tag>
            
            <tag> 教训 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习之道——芭芭拉-奥克利</title>
      <link href="/2018/11/09/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93%E2%80%94%E2%80%94%E8%8A%AD%E8%8A%AD%E6%8B%89-%E5%A5%A5%E5%85%8B%E5%88%A9/"/>
      <content type="html"><![CDATA[<h3 id="太勤奋是一种病"><a href="#太勤奋是一种病" class="headerlink" title="太勤奋是一种病"></a>太勤奋是一种病</h3><h4 id="提升思考"><a href="#提升思考" class="headerlink" title="提升思考"></a>提升思考</h4><blockquote><p>你怎么才能意识到自己处于发散模式中？那是一种什么感觉？</p></blockquote><p>相对于专注模式：沉重，对准，不偏不倚，就像用枪对准了目标一样。</p><p>发散模式，更多的是一种轻松写意的过程，犹如行云流水，不在乎于静；</p><blockquote><p>当你有意识地思考一个问题时，是哪种模式被激活了，哪种被屏蔽了呢？怎么才能解锁被屏蔽的模式呢？</p></blockquote><p>当我有意识的思考一个问题的时候，其实是<strong>专注模式被激活了</strong>，那种感觉就像时间不存在一样，感觉很棒，感觉全世界都只是你一个人；</p><p>很多时候的学习方式都是这种专注模式下不断的重复，时间一久就会觉得自己很不舒服，有点胸闷透不过气来的感觉，然后下次再学习的时候，本能会不自觉的进行抗拒。</p><p>然后就这样不久就形成了拖延的毛病，并且懒得思考了。</p><p>相应的<strong>发散模式被屏蔽了</strong>，这就是一个矛盾体，不可能有人说我既专注又发散的，这么说很奇怪，而且我们不是电脑，没法并发不是。</p><p>如何解锁呢？</p><p>像书里面说的一样，<strong>睡觉，散步，听听音乐放松</strong>，其实还有其他的，一般而言就是打游戏。</p><p>让自己放松下来，转移到其他事务上面，就可以达到解锁的目的；</p><blockquote><p>回顾一下你处于定式效应的时候，怎样才能改变思考方式，跳出预设的错误概念？</p></blockquote><p><strong>学习其他新东西，让自己的思维拓宽；</strong></p><p><strong>重新尝试一段想法，或者说将问题停下来，过一段时间这个问题总能得到更好的解决办法。</strong></p><blockquote><p>解释一下专注模式和发散模式是怎样类比手电筒的可调光束的。何时才能看得更远？何时视野更开阔，但看到的距离更近？</p></blockquote><p>专注模式:强光线集中，将所有的脑力全部集中于一个方向的出口；何时才能看得更远？这个时候更远</p><p>发散模式:散射光线，将脑力由一个出口从不同方向射出；何时视野更开阔，但看到的距离更近？就这个时候而言是这样的；</p><blockquote><p>为什么有时候对于学数学和科学的人来说，克服拖延症格外困难？</p></blockquote><p>专注模式过度集中产生了思维定式的效果，紧盯住某个细节或者方法反复验证，而这个时候需要的是发散模式的思维方式更能解决问题；</p><blockquote><p>官方给定的答案：</p><p>他们通常把自己困在了原地，盯着细节不放。想要在其中找到解决方案，而非理解问题本身。</p></blockquote><h3 id="学习即创造"><a href="#学习即创造" class="headerlink" title="学习即创造"></a>学习即创造</h3><h4 id="提升思考-1"><a href="#提升思考-1" class="headerlink" title="提升思考"></a>提升思考</h4><blockquote><p>列举几项有助于从专注模式切换到发散模式的活动。</p></blockquote><p><strong>睡觉、发呆、冥想、散步、听音乐、打游戏</strong></p><blockquote><p>有时，你会确信自己已经发现了解决问题的新方法，但事实上并没有。那么如何才能更主动地意识到自己的思考过程，拥抱其他可能性呢？是否有必要永远让自己以开放的态度对待新可能？</p></blockquote><p>这里我倒着过来说，是否有必要，有，但是不是以开放态度，而是以审查的方式，对待新可能，</p><blockquote><p>为什么凭借自制力让自己停下来很重要？跳出学习、学术的范畴，你还能想到哪些让“停下”显得很重要的情形呢？</p></blockquote><blockquote><p>学习新概念时，你要在一天之内就再次复习，以免刚接触的新概念随风而逝。但结果往往是有太多事情挤在那里，要过了几天甚至是更久之后才会开始再次复习。你能否制订出一种行动计划，来保证自己及时复习新知识？</p></blockquote><p>未完待续…</p>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>乍看很难，细看很美-傅里叶变换</title>
      <link href="/2018/09/05/%E4%B9%8D%E7%9C%8B%E5%BE%88%E9%9A%BE%EF%BC%8C%E7%BB%86%E7%9C%8B%E5%BE%88%E7%BE%8E-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 傅里叶变换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法之旅-列表搜索</title>
      <link href="/2018/09/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E5%88%97%E8%A1%A8%E6%90%9C%E7%B4%A2/"/>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 列表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法之旅-图表搜索</title>
      <link href="/2018/09/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E5%9B%BE%E8%A1%A8%E6%90%9C%E7%B4%A2/"/>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图表 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法之旅-聚类</title>
      <link href="/2018/09/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E8%81%9A%E7%B1%BB/"/>
      <content type="html"><![CDATA[<h2 id="简介-聚类算法百度百科"><a href="#简介-聚类算法百度百科" class="headerlink" title="简介^聚类算法百度百科"></a>简介<a href="https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">^聚类算法百度百科</a></h2><p>聚类分析又称群分析，它是研究（样品或指标）分类问题的一种统计分析方法，同时也是数据挖掘的一个重要算法。</p><p>聚类（Cluster）分析是由若干模式（Pattern）组成的，通常，模式是一个度量（Measurement）的向量，或者是多维空间中的一个点。</p><p>聚类分析以相似性为基础，在一个聚类中的模式之间比不在同一聚类中的模式之间具有更多的相似性。</p><h2 id="算法起源"><a href="#算法起源" class="headerlink" title="算法起源"></a>算法起源</h2><p>俗话说：“物以类聚，人以群分”，在自然科学和社会科学中，存在着大量的<strong>分类问题</strong>。</p><p>所谓类，通俗地说，就是指相似元素的集合。</p><p>聚类分析起源于分类学，在古老的分类学中，人们主要依靠经验和专业知识来实现分类，很少利用数学工具进行定量的分类。</p><p>随着人类科学技术的发展，<strong>对分类的要求越来越高</strong>，以致有时仅凭经验和专业知识难以确切地进行分类，于是人们逐渐地把数学工具引用到了分类学中，<strong>形成了数值分类学</strong>，之后又<strong>将多元分析的技术引入到数值分类学形成了聚类分析</strong>。</p><p>聚类分析内容非常丰富，有系统聚类法、有序样品聚类法、动态聚类法、模糊聚类法、图论聚类法、聚类预报法等。</p><h2 id="算法用途"><a href="#算法用途" class="headerlink" title="算法用途"></a>算法用途</h2><p>聚类的用途是很广泛的。</p><p>在商业上，聚类可以帮助市场分析人员从消费者数据库中区分出不同的消费群体来，并且概括出每一类消费者的消费模式或者说习惯。</p><p>它作为数据挖掘中的一个模块，可以作为一个单独的工具以发现数据库中分布的一些深层的信息，并且概括出每一类的特点，或者把注意力放在某一个特定的类上以作进一步的分析；</p><p>并且，聚类分析也可以作为数据挖掘算法中其他分析算法的一个预处理步骤。</p><p>聚类分析的算法可以分为<strong>划分法</strong>（Partitioning Methods）、<strong>层次法</strong>（Hierarchical Methods）、<strong>基于密度的方法</strong>（density-based methods）、<strong>基于网格的方法</strong>（grid-based methods）、<strong>基于模型的方法</strong>（Model-Based Methods）。</p><h2 id="聚类要求"><a href="#聚类要求" class="headerlink" title="聚类要求"></a>聚类要求</h2><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>许多聚类算法在小于 200 个数据对象的小数据集合上工作得很好；</p><p>但是，一个大规模数据库可能包含几百万个对象，在这样的大数据集合样本上进行聚类可能会导致有偏的结果。</p><p>我们需要具有高度可伸缩性的聚类算法。</p><p><strong>这里的理解应该是有弹性，聚类的分类的标准应该是弹性的区间，如果死死的固定区间，那么就会存在游离所聚之类的外面；</strong></p><h3 id="不同属性"><a href="#不同属性" class="headerlink" title="不同属性"></a>不同属性</h3><p>许多算法被设计用来聚类数值类型的数据。</p><p>但是，应用可能要求聚类其他类型的数据，如<strong>二元类型</strong>(binary)，<strong>分类/标称类型</strong>（categorical/nominal），<strong>序数型</strong>（ordinal）数据，或者这些数<strong>据类型的混合</strong>。</p><p><strong>聚类不能仅仅给定一个数值区间就可以了的，如上所述在真正的应用过程中，聚合的应该是多属性的数据，多条件的聚合；</strong></p><h3 id="任意形状"><a href="#任意形状" class="headerlink" title="任意形状"></a>任意形状</h3><p><strong>许多聚类算法基于欧几里得或者曼哈顿距离度量来决定聚类（常用聚类算法）。</strong>基于这样的距离度量的算法趋向于发现具有相近尺度和密度的<strong>球状簇</strong>。但是，一个簇可能是任意形状的。<strong>提出能发现任意形状簇的算法是很重要的。</strong></p><p><strong>应该说真正符合现实需求的聚类算法通常的是复杂的，而不是简单的球形结构，应该是任意形状，而又同时符合真正聚合需求的算法。</strong></p><h3 id="领域最小化"><a href="#领域最小化" class="headerlink" title="领域最小化"></a>领域最小化</h3><p>许多聚类算法在聚类分析中要求用户输入一定的参数，例如希望产生的簇的数目。<strong>聚类结果对于输入参数十分敏感。</strong></p><p><strong>参数通常很难确定，特别是对于包含高维对象的数据集来说。</strong>这样不仅加重了用户的负担，也使得聚类的质量难以控制。</p><p><strong>没有真正的对于数据精分，对于聚类的模型没有真正设计到位，才产生了聚类质量难于控制，让用户过多的选择。</strong></p><h3 id="处理“噪声”（干扰）"><a href="#处理“噪声”（干扰）" class="headerlink" title="处理“噪声”（干扰）"></a>处理“噪声”（干扰）</h3><p><strong>绝大多数现实中的数据库都包含了孤立点，缺失，或者错误的数据</strong>。一些聚类算法对于这样的数据敏感，可能导致低质量的聚类结果。</p><p><strong>需要考虑到这种噪点类型数据的量，以及对于聚类整个的模型有何干扰，才能真正避免这类型数据造成的影响。</strong></p><h3 id="记录顺序"><a href="#记录顺序" class="headerlink" title="记录顺序"></a>记录顺序</h3><p>一些聚类算法对于输入数据的顺序是敏感的。</p><p>例如，同一个数据集合，当以不同的顺序交给同一个算法时，可能生成差别很大的聚类结果。开发对数据输入顺序不敏感的算法具有重要的意义。</p><p><strong>应当避开涉及到数据顺序的问题，聚类算法真正需要聚合的对象是什么来操作；</strong></p><h3 id="高维度（high-dimensionality）"><a href="#高维度（high-dimensionality）" class="headerlink" title="高维度（high dimensionality）"></a>高维度（high dimensionality）</h3><p>一个数据库或者数据仓库可能包含若干维或者属性。</p><p><strong>许多聚类算法擅长处理低维的数据，可能只涉及两到三维。</strong></p><p><strong>人类的眼睛在最多三维的情况下能够很好地判断聚类的质量。</strong></p><p><strong>在高维空间中聚类数据对象是非常有挑战性的</strong>，特别是考虑到这样的<strong>数据可能分布非常稀疏</strong>，<strong>而且高度偏斜。</strong></p><p><strong>多条件的进行聚合，其实这里可以对比空间数据的聚合，会更好的理解他所说的这段话</strong></p><h3 id="基于约束"><a href="#基于约束" class="headerlink" title="基于约束"></a>基于约束</h3><p>现实世界的应用可能需要在各种约束条件下进行聚类。</p><p>假设你的工作是在一个城市中为给定数目的自动提款机选择安放位置，为了作出决定，你可以对住宅区进行聚类，同时考虑如城市的河流和公路网，每个地区的客户要求等情况。</p><p><strong>要找到既满足特定的约束，又具有良好聚类特性的数据分组是一项具有挑战性的任务。</strong></p><h3 id="解释性-可用性"><a href="#解释性-可用性" class="headerlink" title="解释性-可用性"></a>解释性-可用性</h3><p><strong>用户希望聚类结果是可解释的，可理解的，和可用的</strong>。</p><p>也就是说，<strong>聚类可能需要和特定的语义解释和应用相联系。</strong></p><p><strong>应用目标如何影响聚类方法的选择也是一个重要的研究课题。</strong></p><hr><p>记住这些约束，我们对聚类分析的学习将按如下的步骤进行。</p><p>首先，学习不同类型的数据，以及它们对聚类方法的影响。</p><p>接着，给出了一个聚类方法的一般分类。</p><p>然后我们详细地讨论了各种聚类方法，包括<strong>划分方法</strong>，<strong>层次方法</strong>，<strong>基于密度的方法</strong>，<strong>基于网格的方法</strong>，以及<strong>基于模型</strong>的方法。最后我们探讨在<strong>高维空间中的聚类</strong>和<strong>孤立点分析（outlier analysis）</strong>。</p><blockquote><p>这里的聚类要求，几乎包含了所有的种类的聚类情况，实际的应用过程中，可能不会有那么多，但是如果所涉及到的要求越高，要求精度越高，那么达成上面所有要求也成为了基本要求；</p></blockquote><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p><strong>很难对聚类方法提出一个简洁的分类，因为这些类别可能重叠，从而使得一种方法具有几类的特征</strong>，尽管如此，对于各种不同的聚类方法提供一个相对有组织的描述依然是有用的，为聚类分析计算方法主要有如下几种：</p><h3 id="划分法"><a href="#划分法" class="headerlink" title="划分法"></a>划分法</h3><p>划分法(partitioning methods)，给定一个有N个元组或者纪录的数据集，分裂法将构造K个分组，每一个分组就代表一个聚类，K&lt;N。而且这K个分组满足下列条件：</p><p>（1） 每一个分组<strong>至少包含一个数据</strong>纪录；<br>（2）<strong>每一个数据纪录属于且仅属于一个分组</strong>（注意：<strong>这个要求在某些模糊聚类算法中可以放宽</strong>）；</p><p>对于给定的K，算法首先给出一个初始的分组方法，以后通过反复迭代的方法改变分组，使得每一次改进之后的分组方案都较前一次好。</p><p>而所谓好的标准就是：<strong>同一分组中的记录越近越好，而不同分组中的纪录越远越好。大部分划分方法是基于距离的。</strong></p><p>给定要构建的分区数k，划分方法首先创建一个初始化划分。</p><p>然后，它采用一种迭代的重定位技术，通过把对象从一个组移动到另一个组来进行划分。</p><p>一个好的划分的一般准备是：同一个簇中的对象尽可能相互接近或相关，而不同的簇中的对象尽可能远离或不同。</p><p>还有许多评判划分质量的其他准则。传统的划分方法可以扩展到子空间聚类，而不是搜索整个数据空间。</p><p>当存在很多属性并且数据稀疏时，这是有用的。<strong>为了达到全局最优，基于划分的聚类可能需要穷举所有可能的划分，计算量极大。</strong></p><p>实际上，大多数应用都采用了流行的启发式方法，如<strong>k-均值和k-中心算法，渐近的提高聚类质量，逼近局部最优解。</strong></p><p><strong>这些启发式聚类方法很适合发现中小规模的数据库中小规模的数据库中的球状簇</strong>。</p><p>为了发现具有复杂形状的簇和对超大型数据集进行聚类，需要进一步扩展基于划分的方法。[^数据挖掘概念与技术]</p><p>使用这个基本思想的算法有：<strong>K-MEANS算法、K-MEDOIDS算法、CLARANS算法</strong>；</p><h3 id="层次法"><a href="#层次法" class="headerlink" title="层次法"></a>层次法</h3><p>层次法(hierarchical methods)，这种方法对给定的数据集进行层次似的分解，直到某种条件满足为止。具体又可分为“自底向上”和“自顶向下”两种方案。</p><p>例如，在“自底向上”方案中，初始时每一个数据纪录都组成一个单独的组，在接下来的迭代中，它把那些相互邻近的组合并成一个组，直到所有的记录组成一个分组或者某个条件满足为止。</p><p>层次聚类方法可以是基于距离的或基于密度或连通性的。层次聚类方法的一些扩展也考虑了子空间聚类。<strong>层次方法的缺陷在于，一旦一个步骤（合并或分裂）完成，它就不能被撤销。</strong></p><p>这个严格规定是有用的，因为不用担心不同选择的组合数目，它将产生较小的计算开销。然而这种技术不能更正错误的决定。已经提出了一些提高层次聚类质量的方法。[^数据挖掘概念与技术] </p><p>代表算法有：<strong>BIRCH算法、CURE算法、CHAMELEON算法</strong>等；</p><h3 id="密度算法"><a href="#密度算法" class="headerlink" title="密度算法"></a>密度算法</h3><p>基于密度的方法(density-based methods)，基于密度的方法与其它方法的一个根本区别是：它不是基于各种各样的距离的，而是基于密度的。</p><p>这样就<strong>能克服基于距离的算法只能发现“类圆形”的聚类的缺点</strong>。</p><p>这个方法的指导思想就是，<strong>只要一个区域中的点的密度大过某个阈值，就把它加到与之相近的聚类中去。</strong></p><p>代表算法有：<strong>DBSCAN算法、OPTICS算法、DENCLUE算法</strong>等；</p><h3 id="图论聚类法"><a href="#图论聚类法" class="headerlink" title="图论聚类法"></a>图论聚类法</h3><p>图论聚类方法解决的第一步是建立与问题相适应的图，<strong>图的节点对应于被分析数据的最小单元，图的边（或弧）对应于最小处理单元数据之间的相似性度量。</strong></p><p>因此，每一个最小处理单元数据之间都会有一个度量表达，这就确保了数据的局部特性比较易于处理。图论聚类法是以样本数据的局域连接特征作为聚类的主要信息源，因而其主要优点是易于处理局部数据的特性。</p><h3 id="网格算法"><a href="#网格算法" class="headerlink" title="网格算法"></a>网格算法</h3><p>基于网格的方法(grid-based methods)，这种方法首先将数据空间划分成为有限个单元（cell）的网格结构,所有的处理都是以单个的单元为对象的。</p><p><strong>这么处理的一个突出的优点就是处理速度很快，通常这是与目标数据库中记录的个数无关的，它只与把数据空间分为多少个单元有关。</strong></p><p>代表算法有：<strong>STING算法、CLIQUE算法、WAVE-CLUSTER算法</strong>；</p><h3 id="模型算法"><a href="#模型算法" class="headerlink" title="模型算法"></a>模型算法</h3><p>基于模型的方法(model-based methods)，基于模型的方法给每一个聚类假定一个模型，然后去寻找能够很好的满足这个模型的数据集。</p><p>这样一个模型可能是数据点在空间中的密度分布函数或者其它。</p><p>它的一个潜在的假定就是：<strong>目标数据集是由一系列的概率分布所决定的</strong>。</p><p>通常有两种尝试方向：<strong>统计的方案和神经网络的方案</strong>。</p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="K-MEANS"><a href="#K-MEANS" class="headerlink" title="K-MEANS"></a>K-MEANS</h3><p>k-means 算法接受输入量 k ；然后将n个数据对象划分为 k个聚类以便使得所获得的聚类满足：同一聚类中的对象相似度较高；</p><p>而不同聚类中的对象相似度较小。聚类相似度是利用各聚类中对象的均值所获得一个“中心对象”（引力中心）来进行计算的。</p><p>k-means 算法的工作过程说明如下：</p><p>首先从n个数据对象任意选择 k 个对象作为初始聚类中心；</p><p>而对于所剩下其它对象，则根据它们与这些聚类中心的相似度（距离），分别将它们分配给与其最相似的（聚类中心所代表的）聚类；</p><p>然后再计算每个所获新聚类的聚类中心（该聚类中所有对象的均值）；</p><p>不断重复这一过程直到标准测度函数开始收敛为止。</p><p>一般都采用均方差作为标准测度函数. k个聚类具有以下特点：各聚类本身尽可能的紧凑，而各聚类之间尽可能的分开。</p><h2 id="其他算法链接地址"><a href="#其他算法链接地址" class="headerlink" title="其他算法链接地址"></a>其他算法链接地址</h2><p><a href="http://blog.langaobai.top/2018/08/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E6%8E%92%E5%BA%8F/">算法之旅-排序算法</a></p><p><a href="http://blog.langaobai.top/2018/09/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E8%81%9A%E7%B1%BB/">算法之旅-聚类算法</a></p><p><a href="">算法之旅-列表搜索算法</a></p><p><a href="">算法之旅-图表搜索算法</a></p><p><a href="">算法之旅-数学类算法</a></p><p><a href="">算法之旅-数据压缩算法</a></p><p><a href="">算法之旅-安全算法</a></p><p><a href="">算法之旅-数据结构</a></p><p>[^数据挖掘概念与技术]: Jiawei Han．数据挖掘概念与技术：机械工业出版社，2012</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你知道或不知道的单元测试</title>
      <link href="/2018/08/30/%E4%BD%A0%E7%9F%A5%E9%81%93%E6%88%96%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <content type="html"><![CDATA[<h3 id="为什么现在才开始"><a href="#为什么现在才开始" class="headerlink" title="为什么现在才开始"></a>为什么现在才开始</h3><p>其实之前有看过关于Junit的测试，也实际操作并践行着，但是总觉得自己还有所欠缺着些东西；</p><p>于是想想，我应该把自己平时对于测试方面，Junit的学习认识，记录下来，然后定期的修改，增补，让自己的知识进行沉积；</p><h3 id="为什么要单元测试"><a href="#为什么要单元测试" class="headerlink" title="为什么要单元测试"></a>为什么要单元测试</h3><p>单元测试的过程，并不是最终面向客户的甚至不是面向项目经理，开发组长，而是面向程序员自己的；</p><p>单元测试一开始就不是冲着为了获得一些更好的整体质量而设计的；</p><p>那为什么程序员还需要单元测试？</p><p>一个没有用处的东西，他存在的理由究竟是什么？</p><p>首先，我们得明白<strong>什么是单元测试？</strong></p><blockquote><p>单元测试是开发者编写的一小段代码，用于检测代码的一个很小的、很明确的功能是否正确。</p><p>执行单元测试是为了证明某段代码的行为确实和开发者期望的一致。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 单元 </tag>
            
            <tag> Junit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法之旅-排序</title>
      <link href="/2018/08/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="入门简介"><a href="#入门简介" class="headerlink" title="入门简介"></a>入门简介</h2><p>算法这门课程在大二大三的时候就已经系统的讲解过，但是由于当时没有深刻理解这门课程的重要性，所以学得不是很用心；</p><p>但是多年以后才明白，如果说，编程的逻辑思维对于程序员来说是一门内力的话，那么算法相当于是精妙的招式了；</p><p>因此在没有好招式之前，只能发挥出自身的一部分实力，只有不断的学习更好的算法，才能将自己的逻辑思维不断最优化的表现出来；</p><p>那么接下来就让我们重新系统的认识一些算法，总结出属于自己的算法之道；</p><p>金庸小说中，任何优秀的武功，都是以招式直接，飘逸灵动的武功最优；</p><p>而古龙的描述更直接，没有多余的招式，直接杀敌才是最好的武功；</p><p>而算法也是这样，只有最直接，最快速，消耗最少的算法才是最优的；</p><p>因此算法的优劣就可以从这几个简单的方向进行思考，如何最快速，最少的消耗解决问题，就是一个算法核心竞争力；</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>虽然是个很简单的排序，但是条条大路通罗马，那么哪条路是最简单，最快速，而又最优的呢？</p><p>这就是一个值得商榷的问题了？</p><h3 id="时间复杂度和稳定性对比"><a href="#时间复杂度和稳定性对比" class="headerlink" title="时间复杂度和稳定性对比"></a>时间复杂度和稳定性对比</h3><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">最好时间</th><th style="text-align:center">平均时间</th><th style="text-align:center">最坏时间</th><th style="text-align:center">铺助空间</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">二分插入</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔</td><td style="text-align:center"></td><td style="text-align:center">$O(n^{1.25})$</td><td style="text-align:center"></td><td style="text-align:center">$O(n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">直接选择</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center"></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(nlgn)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数</td><td style="text-align:center">$O(d(rd+n))$</td><td style="text-align:center">$O(d(rd+n))$</td><td style="text-align:center">$O(d(rd+n))$</td><td style="text-align:center">$O(rd+n)$</td><td style="text-align:center">稳定</td></tr></tbody></table><h3 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h3><h4 id="冒泡排序原理-冒泡排序百度百科"><a href="#冒泡排序原理-冒泡排序百度百科" class="headerlink" title="冒泡排序原理^冒泡排序百度百科"></a>冒泡排序原理<a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="noopener">^冒泡排序百度百科</a></h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数$C​$和记录移动次数$M​$</p><p>均达到最小值：$C_{min}=n-1​$,$M_{min}=0​$， 所以，冒泡排序最好的时间复杂度为$O(n)​$。</p><p>　　若初始文件是反序的，需要进行$n - 1​$趟排序。每趟排序要进行$n-i​$次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>$$<br>C_{max} = \frac{n(n-1)}{2} = O(n^2)\<br>M_{max} = \frac{3n(n-1)}{2} = O(n^2)<br>$$</p><p>冒泡排序的最坏时间复杂度为$O({n^2})​$</p><p>综上，因此冒泡排序总的平均时间复杂度为$O({n^2})​$</p><h4 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    * @Title bubbleSort     * @Description TODO(冒泡排序，第一种排序方式)     * @param array    * @return    * @throws    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**    * @Title bubbleSort     * @Description TODO(冒泡排序，第二种排序方式)     * @param array    * @return    * @throws    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j <span class="token operator">>=</span> i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>都是冒泡法排序，但是随着排序数组的数据量增大，后者的时间消耗会比第一种少很多；</p><p>这里放在一起，是为了便于思考，方便对整个算法进行梳理；</p><h4 id="算法动画演示"><a href="#算法动画演示" class="headerlink" title="算法动画演示"></a><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">算法动画演示</a></h4><h3 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h3><h4 id="算法介绍-快速排序百度百科"><a href="#算法介绍-快速排序百度百科" class="headerlink" title="算法介绍^快速排序百度百科"></a>算法介绍<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">^快速排序百度百科</a></h4><p>快速排序（Quicksort）是对冒泡排序的一种改进。</p><p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此达到整个数据变成有序<strong>序列</strong>。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，<strong>快速排序不是一种稳定的排序算法</strong>，也就是说，<strong>多个相同的值的相对位置也许会在算法结束时产生变动</strong>。</p><p>一趟快速排序的算法是：</p><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</li><li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</li><li>重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</li></ol><blockquote><p>从需要排序的数里面随便找出一个，然后，把<strong>比这个数小的放在这个数左边，比这个数大的放在这个数右边，一样大的和这个数放在一起</strong>，最后，<strong>左右两边各自重复上述过程</strong>，直到左边或右边只剩下一个数（或零个数）无法继续为止。</p></blockquote><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    * @Title partition     * @Description TODO(    * 这里进行分区比较，将左侧大于右侧下标的数据进行交换，    * 然后当左侧下标小于右侧下标进行循环，    * 由右侧下标开始向左侧移动，当遇到右侧下标所属数值小于左侧的时候或者当右侧下标已经移动到左侧同一个下标的时候跳出循环，将右侧下标的值赋值给左侧下标值    * 左侧下标开始向右侧移动，当左侧下标所属值大于初始的左侧第一个值或者右侧下标已经等于左侧下标的时候跳出循环，将左侧下标的值赋值给右侧下标值    * 当left>=right 跳出循环    * 将left初始的key赋值给right；    * 最后返回right下标；    * )     * @param array 数组    * @param left 左侧的下标由0开始    * @param right 右侧下标由array.length-1 —— 0    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 三数取中</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> key <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> key <span class="token operator">&amp;&amp;</span> right <span class="token operator">></span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key <span class="token operator">&amp;&amp;</span> right <span class="token operator">></span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">return</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title swap     * @Description TODO(用于交换两个值)     * @param a 交换的值a    * @param b 交换的值b    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title sort     * @Description TODO(    * 对数组进行排序    * 当左侧下标大于等于右侧下标的时候，结束排序    * 当左侧下标小于右侧下标的时候，进行分区排序，返回    * )     * @param array 需要排序的数组    * @param left 左侧下标    * @param right 右侧下标    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="算法动画演示-1"><a href="#算法动画演示-1" class="headerlink" title="算法动画演示"></a><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">算法动画演示</a></h4><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法介绍-插入排序百度百科"><a href="#算法介绍-插入排序百度百科" class="headerlink" title="算法介绍^插入排序百度百科"></a>算法介绍<a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin" target="_blank" rel="noopener">^插入排序百度百科</a></h4><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数;</p><p>但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据;</p><p>算法适用于<strong>少量数据的排序</strong>，时间复杂度为$O(n^2)​$。是<strong>稳定的排序方法</strong>。</p><p>插入算法把要排序的<strong>数组分成两部分</strong>：</p><p>第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置）;</p><p>而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><blockquote><p>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p></blockquote><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><p>最简单的理解可以是这样的：</p><p>假如数组<code>int a = {5,2,1,3,4}</code></p><p>选定数组中的第一数据和第二个数据进行排序，排序完毕<code>a = {[2,5],1,3,4}</code></p><p>这里我用‘[]’的意思就是表示数组a[0~1]是已经排序的了，这个过程也可以理解为将数组中的第二个数据与第一个比较后，插入了第一个数据的前面；</p><p>接下来就将第三个与前面已经排序好的数据进行比较，不断交换位置；</p><p><code>a = {[2,1,5],3,4}</code></p><p><code>a = {[1,2,5],3,4}</code></p><p>就是将第三个数据与前面排序完毕的数据不断<strong>比较</strong>，<strong>交换</strong>，然后找到合适的位置；</p><p>剩下的数据不断重复第三个数据所做的事情，然后直到这个已经排序完毕的数组占据了数组的所有数据；</p><p>来一更好理解的图</p><p><code>初始： a = {5,2,1,3,4}</code></p><p><code>一轮：a = {[2,5],1,3,4}</code><br><code>二轮：a = {[1,2,5],3,4}</code><br><code>三轮：a = {[1,2,3,5],4}</code><br><code>四轮：a = {[1,2,3,4,5]}</code></p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**    * @Title insertSort     * @Description TODO(可以总结的话就是：不断的扩展数组中已经排定的序列长度，直到这个数组内部的序列达到了这个数组的最大值)     * @param arr 需要排序的数组    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr <span class="token operator">=</span> Util<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="算法动画演示-2"><a href="#算法动画演示-2" class="headerlink" title="算法动画演示"></a><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">算法动画演示</a></h4><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法介绍-归并排序百度百科"><a href="#算法介绍-归并排序百度百科" class="headerlink" title="算法介绍^归并排序百度百科"></a>算法介绍<a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">^归并排序百度百科</a></h4><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法;</p><p>该算法是采用<strong>分治法（Divide and Conquer）的一个非常典型的应用</strong>。</p><p>将已有序的子序列合并，得到完全有序的序列；</p><p>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为<strong>二路归并</strong>。</p><p>分治法将问题<strong>分(divide)</strong>成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之</p><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener"><img src="\img\articlePicture\MergeSortDivideAndConquer.png" alt="分治"></a></p><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><p>所谓归并排序是指将两个或两个以上有序的数列（或有序表），合并成一个仍然有序的数列（或有序表）。这样的排序方法经常用于多个有序的数据文件归并成一个有序的数据文件。归并排序的算法比较简单。</p><p>基本思想方法：</p><p>（1）假设已经有两个有序数列，分别存放在两个数组s，r中；并设i，j分别为指向数组的第一个单元的下标；s有n个元素，r有m个元素。</p><p>（2）再另设一个数组a，k指向该数组的第一个单元下标。</p><p>（3）算法分析（过程）：</p><h4 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h4><p>时间复杂度为O(nlog n) 这是该算法中最好、最坏和平均的时间性能。</p><p>空间复杂度为 O(n)</p><p>比较操作的次数介于(nlogn) / 2和nlogn - n + 1。</p><p>赋值操作的次数是(2nlogn)。归并算法的空间复杂度为：0 (n)</p><p>归并排序比较占用内存，但却是一种<strong>效率高且稳定的算法</strong>。</p><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左边归并排序，使得左子序列有序</span>            <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右边归并排序，使得右子序列有序</span>            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>right<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将两个有序子数组合并操作</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左序列指针</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右序列指针</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//临时数组指针</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//将左边剩余元素填充进temp中</span>            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//将右序列剩余元素填充进temp中</span>            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将temp中的元素全部拷贝到原数组中</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="算法动画演示-3"><a href="#算法动画演示-3" class="headerlink" title="算法动画演示"></a><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">算法动画演示</a></h4><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法介绍-选择排序百度百科"><a href="#算法介绍-选择排序百度百科" class="headerlink" title="算法介绍^选择排序百度百科"></a>算法介绍<a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">^选择排序百度百科</a></h4><p>选择排序（Selection sort）是一种简单直观的排序算法。</p><p>它的工作原理是每一次从待排序的数据元素中<strong>选出最小（或最大）</strong>的一个元素，<strong>存放在序列的起始位置</strong>，直到全部待排序的数据元素排完。</p><p> 选择排序是<strong>不稳定的排序方法</strong>。</p><h4 id="算法性能-1"><a href="#算法性能-1" class="headerlink" title="算法性能"></a>算法性能</h4><p>选择排序的交换操作介于 <code>0</code>和 <code>(n-1)</code> 次之间。选择排序的比较操作为 <code>n(n - 1）/2</code> 次之间。</p><p>选择排序的赋值操作介于 <code>0</code> 和 <code>3 (n - 1）</code> 次之间。</p><p>比较次数<code>O(n^2）</code>，比较次数与关键字的初始状态无关，总的比较次数<code>N=(n-1）+(n-2）+...+1=n*(n-1）/2</code>。</p><p>交换次数<code>O(n）</code>，最好情况是，已经有序，交换0次；</p><p>最坏情况交换n-1次，逆序交换n/2次。<strong>交换次数比冒泡排序少多了</strong>，由于<strong>交换所需CPU时间比比较所需的CPU时间多</strong>，n值较小时，<strong>选择排序比冒泡排序快</strong>。</p><p>选择排序是给每个位置选择当前元素最小的;</p><p>比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第<code>n-1</code>个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。</p><p>那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。</p><p>比较拗口，举个例子，序列<code>5 8 5 2 9</code>，我们知道第一遍选择第1个元素5会和2交换，那么原序列中<strong>两个5的相对前后顺序就被破坏了</strong>，<strong>所以选择排序是一个不稳定的排序算法</strong>。</p><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**    * @Title selectionSort     * @Description TODO    * 选择排序    * 选择无需区中的最小数不断存储在最前面，循环这个过程，直到数组完成所有排序    * @param arr    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 无序区的最小数据数组下标</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 在无序区中找到最小数据并保存其数组下标</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将最小元素放到本次循环的前端</span>            Util<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> minIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="算法动画演示-4"><a href="#算法动画演示-4" class="headerlink" title="算法动画演示"></a><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">算法动画演示</a></h4><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法介绍-堆排序百度百科"><a href="#算法介绍-堆排序百度百科" class="headerlink" title="算法介绍^堆排序百度百科"></a>算法介绍<a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">^堆排序百度百科</a></h4><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，<strong>它是选择排序的一种</strong>。</p><p>可以利用数组的特点快速定位指定索引的元素。</p><p><strong>堆分为大根堆和小根堆，是完全二叉树。</strong></p><p>大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。</p><p>在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶；</p><blockquote><p>堆</p><p>　　堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p></blockquote><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener"><img src="\img\articlePicture\HeapCompare.png" alt="大顶堆和小顶堆"></a></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener"><img src="\img\articlePicture\HeapToArray.png" alt="堆映射为数组的逻辑结构"></a></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><h4 id="算法起源"><a href="#算法起源" class="headerlink" title="算法起源"></a>算法起源</h4><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明了著名的堆排序算法（ Heap Sort )</p><h4 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h4><blockquote><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p></blockquote><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。<br>平均性能 $O(N*logN)$。<br>其他性能<br>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。<br>堆排序是就地排序，辅助空间为$O(1)$.<br>它是不稳定的排序方法。</p><p>（<strong>排序的稳定性</strong>是指如果在排序的序列中，存在前后相同的两个元素的话，<strong>排序前 和排序后他们的相对位置不发生变化</strong>）</p><h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1.构建大顶堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从第一个非叶子结点从下至上，从右至左调整结构</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Util<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将堆顶元素与末尾元素进行交换</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重新对堆进行调整</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）     * @param arr     * @param i     * @param length     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先取出当前元素i</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果左子结点小于右子结点，k指向右子结点</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将temp值放到最终的位置</span>    <span class="token punctuation">}</span></code></pre><h4 id="算法动画演示-5"><a href="#算法动画演示-5" class="headerlink" title="算法动画演示"></a><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank" rel="noopener">算法动画演示</a></h4><h2 id="其他算法链接地址"><a href="#其他算法链接地址" class="headerlink" title="其他算法链接地址"></a>其他算法链接地址</h2><p><a href="http://blog.langaobai.top/2018/08/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E6%8E%92%E5%BA%8F/">算法之旅-排序算法</a></p><p><a href="http://blog.langaobai.top/2018/09/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E8%81%9A%E7%B1%BB/">算法之旅-聚类算法</a></p><p><a href="">算法之旅-列表搜索算法</a></p><p><a href="">算法之旅-图表搜索算法</a></p><p><a href="">算法之旅-数学类算法</a></p><p><a href="">算法之旅-数据压缩算法</a></p><p><a href="">算法之旅-安全算法</a></p><p><a href="">算法之旅-数据结构</a></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 选择排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些版本命名小常识</title>
      <link href="/2018/08/24/%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E5%B0%8F%E5%B8%B8%E8%AF%86/"/>
      <content type="html"><![CDATA[<h5 id="1-Alpha版-内部测试版"><a href="#1-Alpha版-内部测试版" class="headerlink" title="1.Alpha版(内部测试版)"></a>1.Alpha版(内部测试版)</h5><p>  一般只在软件开发公司内部运行，不对外公开。主要是开发者自己对产品进行测试，检查产品是否存在缺陷、错误，验证产品功能与说明书、用户手册是否一致。Alpha版本的产品仍然需要完整的功能测试，而其功能亦未完善，但是可以满足一般需求。因为它是整个软件释出周期中的第一个主要阶段，所以它的名称是“Alpha”，希腊字母中的第一个字母。</p><p>  Alpha版本通常会送交到开发软件的组织或社群中的各个软件测试者，用作内部测试。在市场上，越来越多公司会邀请外部的客户或合作伙伴参与其软件的Alpha测试阶段。这令软件在此阶段有更大的可用性测试。</p><p>  在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。</p><h5 id="2-Beta版-外部测试版"><a href="#2-Beta版-外部测试版" class="headerlink" title="2.Beta版(外部测试版)"></a>2.Beta版(外部测试版)</h5><p>   软件开发公司为对外宣传，将非正式产品免费发送给具有典型性的用户，让用户测试该软件的不足之处及存在问题，以便在正式发行前进一步改进和完善。一般可通过Internet免费下载，也可以向软件公司索取。</p><p>  Beta版本是第一个对外公开的软件版本，是由公众参与的测试阶段。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的臭虫(Bug)。</p><p>  Beta版本的测试者通常是开发软件的组织的客户，他们会以免费或优惠价钱得到软件，但会成为组织的免费测试者。</p><p>  Beta版本主要测试产品的支援和市场反应（在邀请Beta用户时）等。</p><h5 id="3-Demo版-演示版"><a href="#3-Demo版-演示版" class="headerlink" title="3.Demo版(演示版)"></a>3.Demo版(演示版)</h5><p>   主要是演示正式软件的部分功能，用户可以从中得知软件的基本操作，为正式产品的发售扩大影响。如果是游戏的话，则只有一两个关卡可以玩。该版本也可以从Internet上免费下载。</p><h5 id="4-Enhanced版-增强版或加强版"><a href="#4-Enhanced版-增强版或加强版" class="headerlink" title="4.Enhanced版(增强版或加强版)"></a>4.Enhanced版(增强版或加强版)</h5><p>   如果是一般软件，一般称作“增强版”，会加入一些实用的新功能。如果是游戏，一般称作“加强版”，会加入一些新的游戏场景和游戏情节等。这是正式发售的版本。</p><h5 id="5-Free版-自由版"><a href="#5-Free版-自由版" class="headerlink" title="5.Free版(自由版)"></a>5.Free版(自由版)</h5><p>   这一般是个人或自由软件联盟组织的成员制作的软件，希望免费给大家使用，没有版权，一般也是通过Internet免费下载。</p><h5 id="6-Full-Version版-完全版"><a href="#6-Full-Version版-完全版" class="headerlink" title="6.Full Version版(完全版)"></a>6.Full Version版(完全版)</h5><p>  也就是正式版，是最终正式发售的版本。</p><h5 id="7-Shareware版-共享版"><a href="#7-Shareware版-共享版" class="headerlink" title="7.Shareware版(共享版)"></a>7.Shareware版(共享版)</h5><p>  有些公司为了吸引客户，对于他们制作的某些软件，可以让用户通过Internet免费下载的方式获取。不过，此版本软件多会带有一些使用时间或次数的限制，但可以利用在线注册或电子注册成为正式版用户。</p><h5 id="8-Release版-发行版"><a href="#8-Release版-发行版" class="headerlink" title="8.Release版(发行版)"></a>8.Release版(发行版)</h5><p>  不是正式版，带有时间限制，也是为扩大影响所做的宣传策略之一。比如Windows Me的发行版就限制了只能使用几个月，可从Internet上免费下载或由公司免费奉送。</p><p>  Release Candidate（简称RC）指可能成为最终产品的版本，如果没有再出现问题则可释出正式版本。在此阶段，产品包含所有功能亦不会出现严重问题。通常此阶段的产品是接近完整的。</p><p>  微软公司很多时会使用此名称。在1990年代，苹果电脑把在这阶段的产品称为“Golden Master”，而最后的Golden Master为正式版本。这阶段亦称Gamma（更后期的称为Delta，及其后的希腊字母）。</p><h5 id="9-Uprgade版-升级版"><a href="#9-Uprgade版-升级版" class="headerlink" title="9.Uprgade版(升级版)"></a>9.Uprgade版(升级版)</h5><p>  当你有某个软件以前的正式版本时，可以购买升级版，将你的软件升级为最新版。升级后的软件与正式版在功能上相同，但价格会低些，这主要是为了给原有的正版用户提供优惠。</p><h5 id="10-Retail版-（零售版）"><a href="#10-Retail版-（零售版）" class="headerlink" title="10.Retail版 （零售版）"></a>10.Retail版 （零售版）</h5><p>  一般只针对个人的功能不是很全的版本，价格比较低，升级时间也有限制。</p><h5 id="11-Cardware版"><a href="#11-Cardware版" class="headerlink" title="11.Cardware版"></a>11.Cardware版</h5><p>  属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。</p><h5 id="12-Plus版（增强版）"><a href="#12-Plus版（增强版）" class="headerlink" title="12.Plus版（增强版）"></a>12.Plus版（增强版）</h5><p>  不过这种大部分是在程序界面及多媒体功能上增强。</p><h5 id="13-Preview版（预览版）"><a href="#13-Preview版（预览版）" class="headerlink" title="13.Preview版（预览版）"></a>13.Preview版（预览版）</h5><p>  软件商为了满足那些对新版本很关注的人，发布的可以看到大部分功能的测试软件。</p><h5 id="14-Corporation-amp-Enterprise版（企业版）"><a href="#14-Corporation-amp-Enterprise版（企业版）" class="headerlink" title="14.Corporation &amp; Enterprise版（企业版）"></a>14.Corporation &amp; Enterprise版（企业版）</h5><p>  只针对企业发布的全功能版本，价格比较昂贵，服务非常齐全。</p><h5 id="15-Standard版（标准版）"><a href="#15-Standard版（标准版）" class="headerlink" title="15.Standard版（标准版）"></a>15.Standard版（标准版）</h5><p>  软件商推荐大家使用的版本，这种版本一般比较稳定，BUG少。</p><h5 id="16-Mini版"><a href="#16-Mini版" class="headerlink" title="16.Mini版"></a>16.Mini版</h5><p>  迷你版也叫精简版只有最基本的功能，为那些想节省硬盘空间或者不追求华丽的人准备的。</p><h5 id="17-Rip"><a href="#17-Rip" class="headerlink" title="17.Rip"></a>17.Rip</h5><p>  是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！</p><p>  另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。</p><h5 id="18-trial-试用版"><a href="#18-trial-试用版" class="headerlink" title="18. trial 试用版"></a>18. trial 试用版</h5><p>  （含有某些限制，如时间、功能，注册后也有可能变为正式版）</p><h5 id="19-RTM-版"><a href="#19-RTM-版" class="headerlink" title="19.RTM 版"></a>19.RTM 版</h5><p>  这基本就是最终的版本，英文是 Release To Manufactur，意思是发布到生产商。</p><h5 id="20-Unregistered"><a href="#20-Unregistered" class="headerlink" title="20.Unregistered"></a>20.Unregistered</h5><p>  未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。</p><h5 id="21-Regged"><a href="#21-Regged" class="headerlink" title="21.Regged"></a>21.Regged</h5><p>已注册版</p><h5 id="22-Lite"><a href="#22-Lite" class="headerlink" title="22.Lite"></a>22.Lite</h5><p>精简版。</p><h5 id="23-Full-version"><a href="#23-Full-version" class="headerlink" title="23.Full version"></a>23.Full version</h5><p>完整版，属于正式版</p><h5 id="24-SC"><a href="#24-SC" class="headerlink" title="24.SC"></a>24.SC</h5><p>Simplified Chinese简体中文版。</p><h5 id="25-CN"><a href="#25-CN" class="headerlink" title="25.CN"></a>25.CN</h5><p>简体中文版</p><h5 id="26-GBK"><a href="#26-GBK" class="headerlink" title="26.GBK"></a>26.GBK</h5><p>简体中文汉字内码扩展规范版。</p><h5 id="27-TC"><a href="#27-TC" class="headerlink" title="27.TC"></a>27.TC</h5><p> Traditional Chinese繁体中文版。</p><h5 id="28-CHT"><a href="#28-CHT" class="headerlink" title="28.CHT"></a>28.CHT</h5><p>繁体中文版</p><h5 id="29-BIG5"><a href="#29-BIG5" class="headerlink" title="29.BIG5"></a>29.BIG5</h5><p>繁体中文大五码版。</p><h5 id="30-EN"><a href="#30-EN" class="headerlink" title="30.EN"></a>30.EN</h5><p>英文版</p><h5 id="31-Multilanguage"><a href="#31-Multilanguage" class="headerlink" title="31.Multilanguage"></a>31.Multilanguage</h5><p>语言版</p><h5 id="32-UTF8"><a href="#32-UTF8" class="headerlink" title="32.UTF8"></a>32.UTF8</h5><p>Unicode Transformation Format 8 bit，对现有的中文系统不是好的解决方案。</p><h5 id="33-γ（Gamma）版"><a href="#33-γ（Gamma）版" class="headerlink" title="33.γ（Gamma）版"></a>33.γ（Gamma）版</h5><p>相当成熟的测试版，与即将发行的正式版相差无几。</p><h5 id="34-SR版"><a href="#34-SR版" class="headerlink" title="34.SR版"></a>34.SR版</h5><p>修正版或更新版，修正了正式版推出后发现的Bug。</p><p>Final版：正式版。</p><h5 id="35-OEM"><a href="#35-OEM" class="headerlink" title="35.OEM"></a>35.OEM</h5><p>Original Equipment Manufacturer 是给电脑生产厂的版本，无需多说。</p><h5 id="36-FPP"><a href="#36-FPP" class="headerlink" title="36.FPP"></a>36.FPP</h5><p>  Full Packaged Product (FPP)/Retail 就是零售版（盒装软件），这种产品的光盘的卷标都带有”FPP”字样，比如英文WXP Pro的FPP版本的光盘卷标就是WXPFPP_EN，其中WX表示是Windows XP，P是Professional（H是Home），FPP表明是零售版本，EN是表明是英语。获得途径除了在商店购买之外，某些MSDN用户也可以得到。</p><h5 id="37-VLO"><a href="#37-VLO" class="headerlink" title="37.VLO"></a>37.VLO</h5><p>  Volume Licensing for Organizations (VLO) 团体批量许可证（大量采购授权合约），这是为团体购买而制定的一种优惠方式。这种产品的光盘的卷标都带有”VOL”字样，取”Volume”前3个字母，以表明是批量，比如英文WXP Pro的VOL版本的光盘卷标就是WXPVOL_EN，其中WX表示是Windows XP，P是Professional（VOL没有Home版本），VOL表明是团体批量许可证版本，EN是表明是英语。获得途径主要是集团购买，某些MSDN用户也可以得到。</p><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>V（Version）：即版本，通常用数字表示版本号。(如:EVEREST Ultimate v4.20.1188 Beta )</p><p>Build：用数字或日期标示版本号的一种方式。(如:VeryCD eMule v0.48a Build 071112)</p><p>SP：Service Pack，升级包。(如:Windows XP SP 2/VistaSP 1/Windows7SP1)</p>]]></content>
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本 </tag>
            
            <tag> 小常识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于subversion的一些知识</title>
      <link href="/2018/05/31/%E5%85%B3%E4%BA%8Esubversion%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <content type="html"><![CDATA[<p>前面，有一篇文章专门提到了，<strong>重新认识版本管理</strong>，并提到的<strong>版本管理的重要性</strong>；</p><p>作为一名程序员，少不了对自己的要求越来越严格，但是如何严谨的规范和约束自己，包括自己所在的团队呢？</p><p>在之前，我的一位大佬，跟我们说了这么一段话：</p><blockquote><p>做事情呢，一定要讲究 <strong>道</strong>，<strong>法</strong>，<strong>术</strong>，<strong>器</strong>；</p></blockquote><p>前面的各有各的说法，我们着重讲解一下，这个<strong>器</strong>；</p><p>这里我将聚焦在更详细的地方，当然是有出处的——出自《版本管理之道-使用subversion》；</p><p>感兴趣的朋友不妨去下载看看，或者购买纸质的书籍，也不算厚，相信即使你是初学者，一个星期的时间也能读完本书并掌握基础的技能；</p><p>这里算是我的学习笔记，不完全抄自本书，会结合部分自己的见解加以深入思考；</p><h2 id="SVN的基础内容"><a href="#SVN的基础内容" class="headerlink" title="SVN的基础内容"></a>SVN的基础内容</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>版本从何而来呢？每一次的增、删、改都会在SVN（subversion的简写，后面均称为SVN）中标记一个新版本；</p><p>用过CVS（<em>Concurrent Versions System 并行版本系统的简称</em>），就会知道这里有点区别；</p><p><strong>CVS</strong>记录的是<strong>单个文件的版本</strong>,而<strong>SVN</strong>记录的是整个<strong>项目仓库的版本</strong>;</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>很多时候，我们都无法记住r677到底用于干什么的？但我们准能记住V3.0这种，第三正式版本；</p><p>版本控制系统让你可以给<strong>某一时刻的一组文件、或者一些目录或者整个项目分配一个名字</strong>。</p><p>如果你们的项目开发到达了一定程度，你标记为 <strong>v2.0 beta</strong>，你以后就能用这个标签签出他们；</p><blockquote><p>标签是一种很好的跟踪项目代码开发过程中发生重要事件的方式；</p></blockquote><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>当我们一个项目组对同一份源代码添加，修改内容，并进行签入和签出的时候，大家都共享这份源代码；</p><p>我们将这份居于主要地位的源代码称为<strong>主干</strong>；</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1527747888648.png" alt="主干"></p><p>那么<strong>分支</strong>又是一个怎样的需求呢？为什么会产生分支这种情况；</p><p>我们可以把主干和分支想象成你所在的时空和另外一个由你本身所做的出改变而产生的另外一个时空；</p><p>通俗一点说，当我们开发到一定过程的时候， 我们需要发布V2.0版本了，这个时候，上线是需要稳定，和减少bug的；</p><p>你不可能说拿着一堆在开发的东西就给客户，至少你需要粉饰一下，而你能怎么做呢？</p><ol><li>让大家都停下手中的活，向着发布的方向进行改动？</li><li>拷贝到其他地方，重新开始，那怎么比对项目最开始的地方，进行跟踪和修正呢？（别跟我说重开一个服务器什么的）</li></ol><p>这个时候，就产生了这样的需求“分支”；</p><blockquote><p>老实说，我还是觉得这样的解释，弱化了分支的功能，有点强行解释的味道，后面我加深理解，再做扩展；</p></blockquote><p>分支产生以后，主开发团队可以继续对着之前的主线干活；</p><p>而发布团队，则对分支进行修正，比对而又能对过去的问题进行持续的跟踪；</p><p>这里作者还说了一个问题，有人被分支搞到头大，是因为过度使用分支，而这样最后会发现，你在合并的时候，痛苦异常；</p><p>我想这位老兄肯定是穿越了太多的平行空间，就像<strong>盗梦空间</strong>里那样，梦太多回不去了…</p><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1527750672884.png" alt="主干与分支"></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>在这里想到了继续用<strong>盗梦空间</strong>的话题比喻最为合适；</p><p>当我们进入第三层梦的时候，小李子终于修正了富二代费舍的思想，这个时候，需要就需要回归主干，进行<strong>合并</strong>了；</p><p>当然在主干中的行为，修正一些bug，也可以及时的合并到分支上来，也可以想像一下小李子的第二层梦对他第三层梦的影响，在合并的影响下传递到了第三层梦中了。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>学过编程的都知道，加锁，在编程中加锁以后的线程，只能是单个线程访问，不能是多线程同时访问；</p><p>顾明思议，当两个人都要操作同一个源文件的时候，就像我要进房间，而又不允许别人进这个房间，那么我就选择<strong>加锁处理</strong>；</p><h4 id="严格加锁"><a href="#严格加锁" class="headerlink" title="严格加锁"></a>严格加锁</h4><p>被加锁的文件一开始都是<strong>只读</strong>状态，要编辑和修改必须征询项目仓库的同意，在没有其他人编辑同一个文件的时候，项目仓库就会授权给你，其他人这个时候要编辑，仓库就会拒绝；</p><h4 id="乐观加锁"><a href="#乐观加锁" class="headerlink" title="乐观加锁"></a>乐观加锁</h4><p>也就是当你进行签入的时候，项目仓库会先行更新你的本地文件，再让你进行签入；</p><p>但这个时候，版本控制系统不会简单的以项目仓库中最新版本的文件去覆盖你辛苦改过的文件，而是<strong>尝试着去合并项目仓库中所有的改动和你的改动</strong>；</p><p>一般而言严格加锁在使用过程中会出现很多问题，例如：一个人必须要等其他人编辑结束并签入之后才能继续他的工作；</p><p>因此用得更多的反而是乐观加锁处理；</p>]]></content>
      
      <categories>
          
          <category> 版本管理 </category>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVN </tag>
            
            <tag> 版本管理 </tag>
            
            <tag> 程序员必修三部曲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>习惯的力量</title>
      <link href="/2018/05/07/%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F/"/>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>人每天的活动中，有超过40%是习惯的产物，而不是自己主动决定的。</p></blockquote><p>开篇就引人入胜，一个人的工作时间是8小时一天，那么40%也就是3.2小时，接近一半的时间我们都是<strong>自动驾驶模式</strong></p><p>因此习惯就是我们需要挖掘的一个宝藏，<strong>用于提升工作效率，还是生活节奏，或者提升生活方式的不二选择。</strong></p><blockquote><p>我们每天做出的大部分选择似乎都是精心考虑的决策结果，其实不然。这些选择都是习惯的结果。</p></blockquote><p>每天清晨醒来，我知道大部分的人应该是和我一样，都是打开手机，然后刷一下，不管是刷新闻，还是刷微博或者朋友圈。</p><p>之前我一直没有思考早上起来第一瞬间，我该有的行为，只是顺应着。</p><p>但当我认真思考的时候，我发现，其实我还在睡觉，大脑深层次的本我并没有振作着醒来，而是使用<strong>自动驾驶模式</strong>；</p><p><strong>尽管我不想这样，但是这就是习惯。</strong></p><p><strong>既然习惯成为了我们手中，具有优先选择权的一项活动，那么我们没有理由不掌握它，为我们选择对的！</strong></p><h4 id="个体习惯"><a href="#个体习惯" class="headerlink" title="个体习惯"></a>个体习惯</h4><p>在我们认识到习惯给我们带来了巨大的影响，这个时候我们不得不沉思；</p><p>习惯到底怎么形成的呢？怎么就会变成了习惯？</p><p>如何改变创造自己认为对的习惯？</p><p>能成功么？是否有可行性呢？</p><h5 id="习惯的运作方式"><a href="#习惯的运作方式" class="headerlink" title="习惯的运作方式"></a>习惯的运作方式</h5><p>记忆是否真的很重要，哪一段记忆更重要？</p><p>科学家们，在通过对<strong>尤金-保利</strong>失去部分脑组织功能却任然能正常生活的行为研究之后；</p><p>发现了他虽然已经遗失了记忆，但<strong>在大脑深处，也就是脊柱和大脑结合的位置——基底核</strong>仍然在正常工作；</p><p>这部分组织控制着个人的<strong>自动行为</strong>，包括了比如呼吸和吞咽等行为；</p><p>在20世纪90年代，麻省理工的研究人员又针对<strong>基底核</strong>，采用老鼠穿越迷宫时候的脑活动研究，发现老鼠在熟悉路线以前，脑活动频繁，熟悉之后，快速前进大脑几乎没有活动；</p><p>这个过程被称为<strong>“组块化”</strong>，也就是大脑将一系列的行为变成一种自动的惯常行为，而这也是习惯形成的基础。</p><p>我们每天生活就靠这些行为组块（数量没有几百，也有几十），例如刷牙，穿衣服等。</p><p>发生这一现象的原因，科学家归结为：大脑一直在寻找可以省力的方式；</p><p><strong>因为习惯能让大脑得到更多的休息，这种省力的本能是一种大优势。</strong></p><p>这也就解释了，你走路的时候，不会想着先抬起左脚还是右脚，要抬多高的问题。</p><p>习惯是如何产生的。</p><p>这里我用一个大家较为熟悉概念来跟大家说明这个问题，当然其中如果有理解偏差的肯定会有，毕竟这是我消化吸收之后再加工的；</p><p><strong>电脑</strong>——大家都很熟悉的一个东西，电脑在设计之初有模范过人脑的部分功能，所以用电脑比喻一下人脑其实也算合适；</p><p>电脑在运行的时候，一些需要经常处理计算的程序是会被加载到内存里面；</p><p>而这套理论放到人的身上的时候，似乎也是很使用，人的很多行为都是习惯组成，所以最快速的，最平常的一些全部都被加载到身体的<strong>内存</strong>里了；</p><blockquote><p>在大部分的企业中，人们之间有一份心照不宣的默契，个人有野心是好的，但是你折腾过了头，你的同事会联合起来对付你。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
          <category> 管理 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
            <tag> 习惯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本管理——重新认识版本管理</title>
      <link href="/2018/04/19/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <content type="html"><![CDATA[<h4 id="为什么要重新认识？"><a href="#为什么要重新认识？" class="headerlink" title="为什么要重新认识？"></a>为什么要重新认识？</h4><p>我想大多数的人，在最开始的时候，进入编程这块以后，很快由别人带领之下使用了SVN、GIT等的版本管理工具；</p><p>对于如何使用，在多次练习的情况下，对与版本管理有了不小的心得；</p><p>更甚者已经是玩得飞起了，但是我要说的是，我不是，我只用了很多基础的功能，还有更多的东西等待我去挖掘；</p><p>但我相信很多人虽然对版本管理软件很熟悉，但是对于版本管理这个概念还是很陌生，不知道它的真正用处。</p><p>而没有学过的版本管理的人，那么这篇文章将带你认真了解版本管理；</p><h4 id="为什么要使用版本管理"><a href="#为什么要使用版本管理" class="headerlink" title="为什么要使用版本管理"></a>为什么要使用版本管理</h4><pre class=" language-txt"><code class="language-txt">需求第一版.md需求第二版.md需求第二版修改小部分.md需求第二版修改大部分.md需求第二版终极版.md需求究极版.md需求究极版再改.md</code></pre><p>请问，同志，上面的需求版本究竟有几个？他发布了几个？改动了多少？</p><p>这是一个很头疼的问题，你根本不清楚他的一个版本变化过程，在比较上也很困难（难道你一个个文件打开了进行比对？）</p><p>如果说究极版再改部分需要前面的第二版的某部分已经删除了，你是不是得一段段的查找？</p><p>你修改的时候不希望破坏掉修改前的状态，最好就是每修改一段事件，能够保存一个状态，类似系统的自动快照一样，当后面出现问题的时候，可以自由选择复原到之前的某个快照状态； <a href="https://www.cnblogs.com/newlifechou/p/8196395.html" target="_blank" rel="noopener">^博客园</a></p><p>还有一个原因，那就是，最后发布软件的时候很多时候会有多个版本，而生成软件的源代码却往往只有一份，只是在最后编译生成的时候用到不同的部分，大部分代码还是共用的，所以往往需要版本控制，几个版本复制几个文件夹出来； <a href="https://www.cnblogs.com/newlifechou/p/8196395.html" target="_blank" rel="noopener">^博客园</a></p><p>版本控制的过程也是过程追踪记录，成就达成的过程。 <a href="https://www.cnblogs.com/newlifechou/p/8196395.html" target="_blank" rel="noopener">^博客园</a></p><h5 id="标准定义-百度百科"><a href="#标准定义-百度百科" class="headerlink" title="标准定义^百度百科"></a>标准定义<a href="https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/2511538?fr=kg_qa" target="_blank" rel="noopener">^百度百科</a></h5><p>版本管理是为满足不同需求，对同一产品或系统进行局部的改进 和改型所产生的产品或系统系列的变更情况进行记录、跟 踪、维护和控制的过程。 </p><p>主要功能：</p><ol><li><strong>集中管理</strong>档案，安全授权机制：档案集中地存放在服务器上，经<strong>系统管理员</strong>授权给各个用户。用户通过check in和check out的方式访问服务器上的文件，未经授权的用户则无法访问服务器上的文件;</li><li>软件版本升级管理：每次登入时，在服务器上都会生成新的版本，任何版本都可以随时检出编辑;</li><li>加锁功能：在文件更新时保护文件，避免不同的用户更改同一文件时发生冲突;</li><li>提供不同版本源程序的比较;</li></ol><h5 id="使用定义-CSDN博客"><a href="#使用定义-CSDN博客" class="headerlink" title="使用定义^CSDN博客"></a>使用定义<a href="https://blog.csdn.net/cfj68583589/article/details/8523173" target="_blank" rel="noopener">^CSDN博客</a></h5><ol><li>数据备份；</li><li>版本管理，避免版本管理换乱</li><li>提高代码质量；</li><li>提高协同、多人开发的效率；</li><li>明确分工责任；</li></ol><p>既然知道了版本管理如此重要，那么大家又是使用什么方式进行版本管理的呢？</p><p>这就不得不提到的，版本管理发展历程；</p><h4 id="版本发展历程"><a href="#版本发展历程" class="headerlink" title="版本发展历程"></a>版本发展历程</h4><h5 id="手工帐"><a href="#手工帐" class="headerlink" title="手工帐"></a>手工帐</h5><p>最早的时候，我相信，还没有推出现有的版本管理工具的时候，使用的就是手工帐的方式，分别记录各个文件到了哪个版本；</p><p>其实就现有的版本工具而言，只能做到文本式的版本管理，而对应的二进制文件，或者其他的设计图片类文件，还无法使用版本管理工具进行管理；</p><p>只能是依然采用手工帐的方式，当然在计算机的软硬件发展的情况下，就算是手工帐也比之前的手工帐方便许多；</p><h5 id="早期VCS阶段-纵一苇"><a href="#早期VCS阶段-纵一苇" class="headerlink" title="早期VCS阶段^纵一苇"></a>早期VCS阶段<a href="https://www.cnblogs.com/zhangzl419/p/4280202.html" target="_blank" rel="noopener">^纵一苇</a></h5><p>这类系统要求系统的用户必须登录到版本库所在的服务器才能访问版本库。            </p><p>局限性：存在可扩展性方面的问题。</p><h5 id="集中式VCS阶段-纵一苇"><a href="#集中式VCS阶段-纵一苇" class="headerlink" title="集中式VCS阶段 ^纵一苇"></a>集中式VCS阶段 <a href="https://www.cnblogs.com/zhangzl419/p/4280202.html" target="_blank" rel="noopener">^纵一苇</a></h5><p>CVS和SVN解决上述早期版本控制工具的可扩展性问题。</p><p>这类版本控制工具允许程序员通过网络来获取版本库中的代码，并且在修改之后提交回来。</p><p>这类系统解决可扩展性问题是通过客户端来解决的，客户端可以有无数个，但是版本库所在的服务端也还是只有一个，客户端可以随意安装，这样就解决了可扩展性的问题。           </p><p>具体的使用方法：每一个程序员在本地有一个工作目录树，其内容是该版本库中最新的代码。当他们在工作目录树中完成代码修改之后，就把改动提交会该代码库。           </p><p>局限性：在本地工作目录树中只会看到代码的最新版本，如果想要查询历史修改记录，就必须与服务器上的版本库打交道。</p><p>这样要和远程的版本库打交道，就必须使用网络，但是即使今天的互联网处于永不断线的状态，有的时候还是不能上网。</p><p>所以分布式版本控制工具就解决了这个问题，以git为代表的分布式版本控制工具使每个用户在本地都有自己的版本库，而不是连接到公共服务器上的一个公共版本库中去。</p><h5 id="分布式版本控制工具阶段-纵一苇"><a href="#分布式版本控制工具阶段-纵一苇" class="headerlink" title="分布式版本控制工具阶段 ^纵一苇"></a>分布式版本控制工具阶段 <a href="https://www.cnblogs.com/zhangzl419/p/4280202.html" target="_blank" rel="noopener">^纵一苇</a></h5><p>所有的版本控制工具都存储在本地版本库中，向版本库提交代码无需链接远程版本库，所有的历史记录都存储在本地版本库中，向版本库提交代码无须连接远程版本库，而是所有的版本数据都存放在本地版本库中。          </p><p> 分布式版本控制工具程序员之间如何传递各自的修改，如何同步呢？程序员还是将修改上传到项目的主版本库中去。</p><p>有两种实现方式：</p><ol><li>通过git的push操作直接把修改上传到主版本库；</li><li>生成包含少量修改的补丁包，把补丁包提交给项目维护人员，再由项目维护人员更新主版本库。  </li></ol><p>如果想了解更多的，可以看看<a href="http://www.cnblogs.com/vamei/archive/2013/02/21/2918069.html" target="_blank" rel="noopener">版本管理三国志</a>，这篇博主对于版本管理有着更深刻的认识；</p><p>在知道这些以后，那么我们选择哪款软件，或者说选择什么样的管理方式呢？</p><h4 id="版本控制软件分类"><a href="#版本控制软件分类" class="headerlink" title="版本控制软件分类"></a>版本控制软件分类</h4><h5 id="集中式版本管理"><a href="#集中式版本管理" class="headerlink" title="集中式版本管理"></a>集中式版本管理</h5><p>集中式顾名思义就是代码集中到服务器，用的时候每个人把自己需要的被授权的那部分代码下载到自己的计算机上；</p><p>提交也是最后提交到服务器上，服务器可以对代码做很好的控制，但是需要有网络，网络断了，就没法工作了。  </p><p>代表就是SVN,Team Foundation等 </p><h5 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h5><p>分布式自然就是每个人的地方多有一份完全的代码，提交和管理都是在本地进行；</p><p>虽然有远端仓库，不过那是最终提交用的，没联网本地也是完整代码的，只是每次需要最新的代码的时候才必须联网；</p><p>分布式的代表就是git，对应的网上仓库比较有名的就是github. </p><hr><p>在清楚的了解这么多之后，我们就要落到实处了，那么究竟如何管理好我们手头上的代码，<strong>如何有效的进行版本管理呢</strong>？</p><p>我想这才是大家关心的重点，也是我为什么需要重新认识版本管理这个概念；</p><p>这里我先留个空，后面来填写这个坑，我会着重<strong>SVN</strong>,<strong>GIT</strong>这两个具有代表性的版本控制工具进行深入的了解和体会。</p>]]></content>
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
            <tag> 版本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>专注力管理-让你的努力更高效</title>
      <link href="/2018/04/17/%E4%B8%93%E6%B3%A8%E5%8A%9B%E7%AE%A1%E7%90%86-%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%8A%AA%E5%8A%9B%E6%9B%B4%E9%AB%98%E6%95%88/"/>
      <content type="html"><![CDATA[<h4 id="怎么接触到这本书的"><a href="#怎么接触到这本书的" class="headerlink" title="怎么接触到这本书的"></a>怎么接触到这本书的</h4><p>最开始的时候，我也不知道这本书，后面公司组织培训，然后有同事专门对这本书的内容进行了讲解；</p><p>我觉得是本难得的好书，里面干货多多，值得学习一番，或许此前我已经接触过类似，擦边的书籍，但是不妨碍自己再次反思一番；</p><h4 id="本书给我带来的体验"><a href="#本书给我带来的体验" class="headerlink" title="本书给我带来的体验"></a>本书给我带来的体验</h4><h5 id="努力得越多，越不明白"><a href="#努力得越多，越不明白" class="headerlink" title="努力得越多，越不明白"></a>努力得越多，越不明白</h5><p>接触这本书以后，顿时有种醍醐灌顶的感觉，或许很多时候，我其实有想过类似的问题，但是效果却一直不是很好；</p><p>套用书里面的话说，我投入了很多<strong>士兵</strong>（时间），但没有一个好的<strong>将军</strong>（专注力），导致于我失败了一次又一次的战役；</p><p>但这样的事情又每天都上演着，一直以为自己是努力不够，忘却了一个人一天最多有24h，就算压缩睡眠时间到6h，剩下的也就是18h，不可能比别人更多；</p><p>相信有的人一天只睡4-5h，那么是不是那堆人比自己更努力，更厉害了？</p><p>可是卖菜大妈一直都还是卖菜大妈，不管起的多早；</p><h5 id="努力-效果"><a href="#努力-效果" class="headerlink" title="努力!=效果"></a>努力!=效果</h5><p>我相信很多时候，我的行为不管在我自己，还是在别人看来我都是努力的，但是收到的<strong>效果</strong>，我却一直都不满意；</p><p>在和身边的很多同学比较一番之后，我发现了，<strong>我努力带来的结果，仅仅只是好上一点点，收效甚微</strong>；</p><p>仔细反省一番之后，<strong>诚如书中所说的那样，我有意无意的陷入了一种颇为讽刺的自我陶醉中</strong>；</p><p>而书里面给出了这样的一句话：<strong>努力的核心是专注</strong>；</p><p><img src="\img\articlePicture\AbsorbedStrive.jpg" alt="@努力！=走上人生巅峰"></p><p><strong>警惕自己的努力，它可能是无效的努力。</strong></p><p>这句话，简直是直击要害，如果严格点，很时候，你做的事情，一点价值都没有，完全否定了；</p><p>实际情况偏偏是这样，太多时候，如果没有经过认真反思，和专注的努力，最后的效果可以说跟没效果是没区别的；</p><h5 id="聚焦核心"><a href="#聚焦核心" class="headerlink" title="聚焦核心"></a>聚焦核心</h5><p>书籍里面将努力的<strong>瞄准</strong>定位到了<strong>专注力</strong>上面；</p><p>而围绕专注力收到的影响，归为了三类：</p><ul><li>目标</li><li>能力</li><li>心态</li></ul><p>在这三类的影响之下，很多人走神了，更夸张点的失神了，完全启动了<strong>自动驾驶模式</strong>；</p><p>根据这三点，又做再次的延伸，如何针对性的解决；</p><h4 id="是什么让我觉得这是本好书"><a href="#是什么让我觉得这是本好书" class="headerlink" title="是什么让我觉得这是本好书"></a>是什么让我觉得这是本好书</h4><h5 id="书短"><a href="#书短" class="headerlink" title="书短"></a>书短</h5><p>很奇怪，跟原来的印象不一样了，我们都知道很多的经典，都是很长的；</p><p>而且在我们的意识里面，我们会最先想到的是，读的书越厚，那么获取到的越多；</p><p>这样我就陷入了最早开始说的，陷入了一种没有效果的死循环；</p><p>真正有用，而且专注的必然不会太长，而需要消化的时间必然不是很短的一个过程；</p><h5 id="内容精简"><a href="#内容精简" class="headerlink" title="内容精简"></a>内容精简</h5><p>跟现在的书比起来，动不动就是各种方法，这本书的内容算少的；</p><p>或许因为少，所以这本书的定位，是一小时电子书；</p><p>让我们本身就专注在一小时内理解本书的用意和具体的操作方法；</p><h5 id="方法实用"><a href="#方法实用" class="headerlink" title="方法实用"></a>方法实用</h5><p>书里面推荐了一些方法，很多人之前其实都接触过；</p><p>例如现在较为流行的<strong>番茄工作法</strong>等；</p><blockquote><p>一小时你能做什么，如何让它更高效，这部书给你答案；</p></blockquote>]]></content>
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专注 </tag>
            
            <tag> 管理 </tag>
            
            <tag> 高效 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>json与bson的区别</title>
      <link href="/2018/03/10/json%E4%B8%8Ebson%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>bson是由10gen开发的一个数据格式，目前主要用于mongoDB中，是mongoDB的数据存储格式。bson基于json格式，选择json进行改造的原因主要是json的通用性及json的schemaless(无模式)的特性。</p><h3 id="bson主要方向"><a href="#bson主要方向" class="headerlink" title="bson主要方向"></a>bson主要方向</h3><h4 id="更快的遍历速度"><a href="#更快的遍历速度" class="headerlink" title="更快的遍历速度"></a>更快的遍历速度</h4><p>对json格式来说，太大的json结构会导致数据遍历非常慢。在json中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配，比如括号的匹配。 </p><p>而bson对json的一大改进就是，它会将json的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。</p><h4 id="操作更简易"><a href="#操作更简易" class="headerlink" title="操作更简易"></a>操作更简易</h4><p>对json来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个，所以可能其后面的所有内容都需要往后移一位才可以。 </p><p>而使用bson，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改，不会导致数据总长变大。 </p><p>当然，在mongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。</p><h4 id="增加了额外的数据类型"><a href="#增加了额外的数据类型" class="headerlink" title="增加了额外的数据类型"></a>增加了额外的数据类型</h4><p>json是一个很方便的数据交换格式，但是其类型比较有限。 </p><p>bson在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成json，大大减少了计算开销和数据大小。 </p><p>当然，在有的时候，bson相对json来说也并没有空间上的优势，比如对{“field”:7}，在json的存储上7只使用了一个字节，而如果用bson，那就是至少4个字节（32位）</p><p>目前在10gen的努力下，bson已经有了针对多种语言的编码解码包。并且都是<em>Apache2 license</em>下开源的。并且还在随着mongoDB进一步地发展。</p><h3 id="json与bson对比"><a href="#json与bson对比" class="headerlink" title="json与bson对比"></a>json与bson对比</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>json是像<strong>字符串存储</strong>的，bson是按<strong>结构存储</strong>的（像数组 或者说struct）</p><h4 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h4><p>bson&gt;json</p><h4 id="操作速度"><a href="#操作速度" class="headerlink" title="操作速度"></a>操作速度</h4><p>bson&gt;json。比如，遍历查找：json需要扫字符串，而bson可以直接定位</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>json也要大动大移，bson就不需要。</p><p>在大多数情况下，JSON和BSON非常相似，但BSON可以提供额外的速度冲击。当然，两者都是应用程序存储和检索数据非常方便的方法。</p><blockquote><p>转自<a href="http://blog.csdn.net/xiaojin21cen/article/details/60953980" target="_blank" rel="noopener">张山的博客专栏</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 数据格式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSON </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB</title>
      <link href="/2018/03/10/MongoDB/"/>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近学习到React-Native，需要学习一下Facebook推出的f8app例子；</p><blockquote><p>MongoDB介绍</p></blockquote><p>MongoDB 是一个基于分布式文件存储的数据库。由<strong>C++语言编写</strong>。<strong>旨在为WEB</strong>应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB <strong>是一个介于关系数据库和非关系数据库之间的产品</strong>，是非关系数据库当中功能最丰富，最像关系数据库的(<em>听着像小品界最会唱歌的小沈阳</em>)。他支持的数据结构非常松散，是类似json的bson(<strong>Binary Serialized Document Format</strong>)<strong>是一种二进制形式的存储格式</strong>，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是他支持的查询语言非常强大，<strong>其语法有点类似于面向对象的查询语言</strong>，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>这里不得不说一下，其实他是NoSQL(NoSQL = Not Only SQL,意即“不仅仅是SQL”)数据库的一种。</p><p>扩展一下，HBase数据库也是NoSQL的一种。</p><blockquote><p>特点</p></blockquote><ol><li>支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li><li>文件存储格式为BSON（一种JSON的扩展）。<a href="http://blog.langaobai.top/2018/03/10/json与bson的区别/">JSON与BSON</a></li><li>可通过网络访问。</li></ol><p>此处抄于百度词条，如果有错，不要找我…</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>而其中需要用到MongDB，我下载的是3.6版本的，需要下载的请点击<a href="https://www.mongodb.com/download-center#atlas" target="_blank" rel="noopener">MongoDB</a></p><p>一路点击<kbd>Next</kbd>就可以了，当然前提是你知道你要安装在什么地方。</p><p>直达最后，安装界面提示你，可能要花些时间，但是这个时间很说不准，万一卡了呢，那么你只能关闭了，不过不要担心，下次开机的时候，其实你已经安装好了，不行你就再装一遍。</p><h3 id="API学习"><a href="#API学习" class="headerlink" title="API学习"></a>API学习</h3><p>安装好以后，我们就该学习了，<a href="https://docs.mongodb.com/" target="_blank" rel="noopener">MongoDB API</a></p><p>未完待续…</p>]]></content>
      
      <categories>
          
          <category> MongDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongDB </tag>
            
            <tag> BSON </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle常用命令</title>
      <link href="/2018/03/09/Oracle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<h3 id="Oracle表空间创建"><a href="#Oracle表空间创建" class="headerlink" title="Oracle表空间创建"></a>Oracle表空间创建</h3><ol><li>创建临时表空间<pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">temporary</span> <span class="token keyword">tablespace</span> YNMZCK_TEMP  tempfile <span class="token string">'D:\Install_file\app\Administrator\oradata\orcl\YNMZCK_TEMP.dbf'</span> size 50m  autoextend <span class="token keyword">on</span>  <span class="token keyword">next</span> 50m maxsize 20480m  extent management <span class="token keyword">local</span><span class="token punctuation">;</span></code></pre></li><li>创建数据表空间<pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">tablespace</span> YNMZCK  logging  datafile <span class="token string">'D:\Install_file\app\Administrator\oradata\orcl\YNMZCK.dbf'</span> size 50m  autoextend <span class="token keyword">on</span>  <span class="token keyword">next</span> 50m maxsize 20480m  extent management <span class="token keyword">local</span><span class="token punctuation">;</span></code></pre></li><li><p>创建用户并指定表空间</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">user</span> YNMZCK identified <span class="token keyword">by</span> YNMZCK<span class="token keyword">default</span> <span class="token keyword">tablespace</span> YNMZCK  <span class="token keyword">temporary</span> <span class="token keyword">tablespace</span> YNMZCK_TEMP<span class="token punctuation">;</span></code></pre></li><li><p>给用户授予权限</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">connect</span><span class="token punctuation">,</span>resource<span class="token punctuation">,</span><span class="token number">dba</span> <span class="token keyword">to</span> YNMZCK<span class="token punctuation">;</span></code></pre></li></ol><h3 id="Oracle导入-导出dmp"><a href="#Oracle导入-导出dmp" class="headerlink" title="Oracle导入/导出dmp"></a>Oracle导入/导出dmp</h3><ol><li><p>导出命令</p><pre class=" language-bash"><code class="language-bash">exp YNMZCC/YNMZCC@orcl  file<span class="token operator">=</span>d:\ynmzcc.dmp owner <span class="token operator">=</span> YNMZCC</code></pre></li><li><p>导入命令</p><pre class=" language-bash"><code class="language-bash">imp username/password@SID file<span class="token operator">=</span>XXX.dmp fromuser<span class="token operator">=</span>XXX touser<span class="token operator">=</span>XXX tables<span class="token operator">=</span><span class="token punctuation">(</span>XXX,XXX<span class="token punctuation">)</span></code></pre></li></ol><h3 id="Oracle清空或者删除当前用户下所有的表"><a href="#Oracle清空或者删除当前用户下所有的表" class="headerlink" title="Oracle清空或者删除当前用户下所有的表"></a>Oracle清空或者删除当前用户下所有的表</h3><ol><li>使用客户端</li></ol><pre class=" language-bash"><code class="language-bash">使用pl/sql客户端，使用该用户登录，选中所有表 右键drop即可</code></pre><ol start="2"><li>动态生成删除命令（<strong>要求用户有相应权限</strong>）</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token string">'drop table '</span><span class="token operator">||</span>table_name<span class="token operator">||</span><span class="token string">';'</span> <span class="token keyword">from</span> user_tables<span class="token punctuation">;</span>  </code></pre><ol start="3"><li>使用存储过程删除该用户下所有表</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> ECHO <span class="token keyword">ON</span>  <span class="token keyword">set</span> define <span class="token keyword">off</span>       SPOOL logs<span class="token operator">/</span>create_procedure<span class="token punctuation">.</span>log  <span class="token comment" spellcheck="true">--删除所有表的存储过程;    </span><span class="token keyword">create</span> <span class="token operator">or</span> replace <span class="token keyword">procedure</span> P_DROP_ALL_TABLE  <span class="token keyword">as</span>     <span class="token comment" spellcheck="true">--引用user_tables表中的tableName的类型;  </span>  tableName user_tables<span class="token punctuation">.</span>table_name<span class="token operator">%</span><span class="token keyword">type</span><span class="token punctuation">;</span>      <span class="token keyword">type</span> ty <span class="token operator">is</span> record<span class="token punctuation">(</span>table_name varchar2<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--定义ref类型游标;-强类型  </span>  <span class="token keyword">type</span> ref_type <span class="token operator">is</span> ref <span class="token keyword">cursor</span> <span class="token keyword">return</span> ty<span class="token punctuation">;</span>    ref_t ref_type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--定义变量存储数量;  </span>  mycount number<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">begin</span>      <span class="token comment" spellcheck="true">--打开游标;  </span>    <span class="token keyword">open</span> ref_t <span class="token keyword">for</span> <span class="token keyword">select</span> table_name <span class="token keyword">from</span> user_tables<span class="token punctuation">;</span>           loop               <span class="token comment" spellcheck="true">--从游标中获取一条记录,放入变量中;  </span>             <span class="token keyword">fetch</span> ref_t <span class="token keyword">into</span> tableName<span class="token punctuation">;</span>                      <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> mycount <span class="token keyword">FROM</span> user_tables <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> tableName<span class="token punctuation">;</span>                      <span class="token keyword">if</span> mycount<span class="token operator">></span><span class="token number">0</span> <span class="token keyword">then</span>                         <span class="token keyword">execute</span> immediate <span class="token string">'DROP TABLE '</span><span class="token operator">||</span>tableName <span class="token operator">||</span> <span class="token string">' CASCADE CONSTRAINT '</span><span class="token punctuation">;</span>                      <span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span>               <span class="token keyword">exit</span> <span class="token keyword">when</span> ref_t<span class="token operator">%</span>notfound<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--退出;  </span>         <span class="token keyword">end</span> loop<span class="token punctuation">;</span>       <span class="token keyword">close</span> ref_t<span class="token punctuation">;</span>        <span class="token keyword">end</span><span class="token punctuation">;</span>  <span class="token operator">/</span>  </code></pre><p>清除的话，将 <strong>drop</strong> 替换为 <strong>truncate</strong> 或者 <strong>delete</strong> ,过程 同上</p><h3 id="如何使用sql语句操作表中的字段"><a href="#如何使用sql语句操作表中的字段" class="headerlink" title="如何使用sql语句操作表中的字段"></a>如何使用sql语句操作表中的字段</h3><ol><li>新增字段</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 时间字段 <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> SYSDATE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 新增</span><span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">COLUMN</span> 表名<span class="token punctuation">.</span>时间字段 <span class="token operator">IS</span> <span class="token string">'系统时间'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span></code></pre><ol start="2"><li>修改字段</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 要修改的字段 VARCHAR2（<span class="token number">12</span>）<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 修改</span><span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">COLUMN</span> 表名<span class="token punctuation">.</span>要修改的字段 <span class="token operator">IS</span> <span class="token string">'系统时间'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 注释</span></code></pre><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h3><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">user</span> 用户名称 <span class="token keyword">cascade</span><span class="token punctuation">;</span></code></pre><h4 id="删除表空间-1"><a href="#删除表空间-1" class="headerlink" title="删除表空间"></a>删除表空间</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">tablespace</span> 表空间名称 including contents <span class="token operator">and</span> datafiles <span class="token keyword">cascade</span> <span class="token keyword">constraint</span><span class="token punctuation">;</span></code></pre><h3 id="根据表相关信息进行查询"><a href="#根据表相关信息进行查询" class="headerlink" title="根据表相关信息进行查询"></a>根据表相关信息进行查询</h3><h4 id="根据表信息查询表"><a href="#根据表信息查询表" class="headerlink" title="根据表信息查询表"></a>根据表信息查询表</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- UTC可接字段</span><span class="token comment" spellcheck="true">-- TABLE_NAME 表名</span><span class="token comment" spellcheck="true">-- TABLE_TYPE 表类型</span><span class="token comment" spellcheck="true">-- COMMENTS 注释</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> USER_TAB_COMMENTS UTC <span class="token keyword">WHERE</span> UTC<span class="token punctuation">.</span>COMMENTS <span class="token operator">LIKE</span> <span class="token string">'%comment%'</span></code></pre><h4 id="根据表字段查询"><a href="#根据表字段查询" class="headerlink" title="根据表字段查询"></a>根据表字段查询</h4><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- TABLE_NAME 表名</span><span class="token comment" spellcheck="true">-- COLUMN_NAME 字段名称</span><span class="token comment" spellcheck="true">-- COMMENTS 字段注释</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> USER_COL_COMMENTS <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'TABLE_NAME'</span></code></pre><h3 id="delete数据恢复"><a href="#delete数据恢复" class="headerlink" title="delete数据恢复"></a>delete数据恢复</h3><h4 id="打开Flash存储的权限"><a href="#打开Flash存储的权限" class="headerlink" title="打开Flash存储的权限"></a>打开Flash存储的权限</h4><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename <span class="token keyword">ENABLE</span> <span class="token keyword">row</span> movement <span class="token punctuation">;</span></code></pre><h4 id="把表还原到指定时间点"><a href="#把表还原到指定时间点" class="headerlink" title="把表还原到指定时间点"></a>把表还原到指定时间点</h4><pre class=" language-sql"><code class="language-sql">flashback <span class="token keyword">table</span> tablename <span class="token keyword">to</span> <span class="token keyword">timestamp</span> to_timestamp<span class="token punctuation">(</span><span class="token string">'2008-02-28 10:40:00'</span><span class="token punctuation">,</span><span class="token string">'yyyy-mm-dd hh24:mi:ss'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="drop数据恢复（未重建同名的表时才有用）"><a href="#drop数据恢复（未重建同名的表时才有用）" class="headerlink" title="drop数据恢复（未重建同名的表时才有用）"></a>drop数据恢复（未重建同名的表时才有用）</h4><pre class=" language-sql"><code class="language-sql">flashback <span class="token keyword">table</span> tbl_corpinfo <span class="token keyword">to</span> before <span class="token keyword">drop</span><span class="token punctuation">;</span></code></pre><h3 id="oracle数据库的最大连接数"><a href="#oracle数据库的最大连接数" class="headerlink" title="oracle数据库的最大连接数"></a>oracle数据库的最大连接数</h3><h4 id="查询连接数"><a href="#查询连接数" class="headerlink" title="查询连接数"></a>查询连接数</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> parameter processes<span class="token punctuation">;</span><span class="token keyword">show</span> parameter sessions<span class="token punctuation">;</span></code></pre><h4 id="修改连接数"><a href="#修改连接数" class="headerlink" title="修改连接数"></a>修改连接数</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> system <span class="token keyword">set</span> processes<span class="token operator">=</span><span class="token number">500</span> scope<span class="token operator">=</span>spfile<span class="token punctuation">;</span><span class="token keyword">alter</span> system <span class="token keyword">set</span> sessions<span class="token operator">=</span><span class="token number">500</span> scope<span class="token operator">=</span>spfile<span class="token punctuation">;</span></code></pre><p>重启服务,修改的连接数就会生效。</p>]]></content>
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MODBUS协议</title>
      <link href="/2018/03/09/MODBUS%E5%8D%8F%E8%AE%AE/"/>
      <content type="html"><![CDATA[<h4 id="情况介绍"><a href="#情况介绍" class="headerlink" title="情况介绍"></a>情况介绍</h4><p>最近公司项目有部分涉及到一个库位灯的通讯，因此我需要对该协议有个具体的了解；</p><p>在之前我并没有接触过这个协议甚至不明白这是啥，能用来做啥的。</p><p>我们首先对<strong>协议</strong>这个特定的词汇进行深入解读一下，避免一些语文差点的同学搞不清楚；</p><p>如果需要对这个汉语有更深入的了解，可以百度一下；</p><p>我们这里用自己的话说一下，其实就是方言，例如你说温州话，或者英语，而你也只能听懂这类话，我们因此把这种说温州话或者英语的标准称为协议。</p><p>上面我们说了一堆废话，那么从下面开始，我们进入正题；</p><p>我们需要与库位灯进行沟通，那么就需要一种方言——<em>协议</em>。</p><p>就让我们了解下什么是MODBUS协议；</p><h4 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h4><p><strong>Modbus 是一个请求/应答协议。</strong></p><p><strong>它已经成为一通用工业标准。有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。</strong></p><p>MODBUS协议支持传统的RS-232、RS-422、RS-485和以太网设备。许多工业设备，包括PLC，DCS，智能仪表等都在使用Modbus协议作为他们之间的通讯标准。</p><p>MODBUS通讯协议，是1979年由美国Modicon 公司提出的，就是被称为PLC 之父的迪克·莫利先生创造的品牌。</p><p><strong>MODBUS是世界上第一个用于工业现场的总线协议</strong>，可以说，它的出现标志着工业现场从模拟量时代向通讯时代迈进。。</p><h4 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h4><p>既然是协议，那么它究竟如何定义，它的规范又是什么呢？</p><p>从程序的角度出发，快速定义：</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><h5 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h5><p>安装modbus仿真工具<a href="http://www.modbustools.com/download.html" target="_blank" rel="noopener">Modbus Slave</a>, 用来模仿一台Modbus协议设备</p><p>1.安装完毕之后的界面是这样的：</p><p><img src="\img\articlePicture\ModbusSlaveIcon.png" alt="安装好之后的样子"></p><p>2.启动后的界面：</p><p><img src="\img\articlePicture\ModbusSlaveLunch.png" alt="启动之后的样子"></p><p>3.选中仿真的设备，然后进行设定，或者鼠标点击按<strong>F8</strong></p><p><img src="\img\articlePicture\ModbusSlaveOperat.png" alt="启动之后的样子"></p><p>4.这里我参考了别人对于Function的理解</p><p>4.1 个人理解版本</p><ul><li>可以读写的布尔类型(0x)</li><li>只能读的布尔类型(1x)</li><li>只能读的数字类型(3x)</li><li>可以读写的数字类型(4x)</li></ul><p>4.2 jamod也提供了操作每种不同类型使用不同的类，这里我列个表</p><table><thead><tr><th>类型</th><th>请求类</th><th>响应类</th></tr></thead><tbody><tr><td>可以读写的布尔类型(0x)</td><td>ReadCoilsRequest</td><td>ReadCoilsResponse</td></tr><tr><td>只能读的布尔类型(1x)</td><td>ReadInputDiscretesRequest</td><td>ReadInputDiscretesResponse</td></tr><tr><td>只能读的数字类型(3x)</td><td>ReadInputRegistersRequest</td><td>ReadInputRegistersResponse</td></tr><tr><td>可以读写的数字类型(4x)</td><td>ReadMultipleRegistersRequest</td><td>ReadMultipleRegistersResponse</td></tr></tbody></table><p>5.设定成功以后选择上部的菜单<kbd>Connection</kbd>，选择<strong>Modebus TCP/IP</strong>，在<strong>TCP/IP Server</strong>栏进行进行配置，如图</p><p><img src="\img\articlePicture\ModbusSlaveConnect.png" alt="Modbus Connect"></p><p>启动之后，红色的No Connection就会消失了；</p><h5 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h5><p>如果你使用的也是java，好吧，这里仅仅介绍java的，其他另外想办法吧。</p><p>可以到maven仓库去下载这个<a href="http://mvnrepository.com/artifact/net.wimpi/jamod/1.2" target="_blank" rel="noopener">jamod.jar</a></p><h5 id="java编程部分-源码"><a href="#java编程部分-源码" class="headerlink" title="java编程部分^源码"></a>java编程部分<a href="详细的可以从GitHub上下载源代码,具体见文章最后">^源码</a></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ModbusUtil</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * @Title: readDigitalInput     * @Description: TODO(只能读的布尔类型(1x))     * @autor hongpeng.zhang    * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readDigitalInput</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: readInputRegister     * @Description: TODO(只能读的数字类型(3x))     * @autor hongpeng.zhang    * @param ip IP地址    * @param port 端口    * @param address 内部寄存器地址，PLC地址    * @param slaveId modbus设备地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readInputRegister</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: readDigitalOutput     * @Description: TODO(可以读写的布尔类型(0x))     * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readDigitalOutput</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: readRegister     * @Description: TODO(读取可以读写的数字类型(4x))     * @autor hongpeng.zhang    * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @return    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readRegister</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span><span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: writeRegister     * @Description: TODO(写入数据到真机，数据类型是RE,用于写到寄存器地址，相应数据，这里需要注意的是，针对的设备必须是可以读写的数字类型，而非另外三种)     * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @param value 需要设置的值    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeRegister</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * @Title: writeDigitalOutput     * @Description: TODO(写入数据到真机的DO类型的寄存器上面)     * @param ip IP地址    * @param port 端口    * @param slaveId modbus设备地址    * @param address 内部寄存器地址，PLC地址    * @param value 需要设置的值    * @throws     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeDigitalOutput</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> slaveId<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>上面的部分引自<strong>核心代码</strong>部分，需要直接操作的，可以直接找到这个类，我已经对照进行注释了；</p><p>内部使用的变量字符都可以对照着模拟仿真对应的设置参数；</p><blockquote><p>本文中的代码部分，以及代码操作部分引 <a href="https://www.cnblogs.com/Dn9x/p/4298146.html" target="_blank" rel="noopener">Dn9x</a> <a href="https://github.com/Dn9x/dn-modbus" target="_blank" rel="noopener">GitHub地址</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> MODBUS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MODBUS </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello,大家好，这是我在git上开通的博客</title>
      <link href="/2016/09/22/hello-%E5%A4%A7%E5%AE%B6%E5%A5%BD%EF%BC%8C%E8%BF%99%E6%98%AF%E6%88%91%E5%9C%A8git%E4%B8%8A%E5%BC%80%E9%80%9A%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p>这里采用了<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>作为搭建工具</p><p>具体的演示内容就不在这进行多余的叙述，搭建的过程也是困难重重。</p><p>一开始就遇到一个问题，不论如何都是不对，后面根据知乎里面一个大神的解答，终于能够顺利发布版本进行更新。</p><blockquote><p>以下是那位大神的解答</p></blockquote><pre class=" language-bash"><code class="language-bash">首先清空 $ hexo clean然后在你建立的博客文件夹下删除.deploy_git$ <span class="token function">git</span> config --global core.autocrlf <span class="token boolean">false</span>重新导出：$ hexo g发布版本: $ hexo d</code></pre><p><em>这里的3，代表的意思是配置git的全局变量，关闭它的自动换行功能，当然了，针对其中的工作原理可以选择使用其他的配置方式，不一定要采用关闭的方式。</em></p><hr><p><strong>至于其他的初始化，如何进行配置等，这里不做详细指导</strong><br>各位可以通过百度或者谷歌就能找到答案；</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/baidu_verify_UJnzbcntPV.html"/>
      <content type="html"><![CDATA[UJnzbcntPV]]></content>
    </entry>
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<blockquote><p>蓝告白的博客，langaobai‘s blog’</p></blockquote><p>俗话说的好，<strong>好记性不如烂笔头</strong>，这是我的个人博客；</p><p>一直以来都没有好好记录和整理一下关于自己的东西；</p><p>原来建立博客的时候还是两年前的事情了，但直到最近才发现自己很多时候，<strong>没有记录，意味着自己没有好好沉淀属于自己的东西。</strong></p><p>博客会记录关于三个方面的东西，<strong>IT技术</strong>，<strong>书籍</strong>，<strong>电影</strong></p>]]></content>
    </entry>
    
    <entry>
      <title>标签云</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>走廊</title>
      <link href="/gallery/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>时间桥</title>
      <link href="/timeline/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
